* What is this file about ?
  This is my personal emacs configuration, which I started all over on <2024-07-12 Fr> because I was fed up with problems in the old config.
** My Target
   With this file I want to configure emacs instances on arch and os x. Also exwm on arch.
* Personal Information
  If you need to contact me, here is my mail.

* Startup customizatio Start server
** Starting the emacs server from here.
   Notes on server. I do not use the server call `(server-start)` anymore, because systemd and emacs server with exwm running in client works for me ONLY.

* Setup package install
  To be able to install packages inside of emacs, we need to make sure emacs knows where to get those packages from. Just like with any other package manager.
   #+BEGIN_SRC elisp
     (require 'package)

     (setq package-archives '(("melpa" . "http://melpa.org/packages/")
			      ("org" . "http://orgmode.org/elpa/")
			      ("elpa" . "http://elpa.gnu.org/packages/")))

	   ;;(package-initialize)

	   (unless package-archive-contents
	(package-refresh-contents))

     (require 'use-package)
     (setq use-package-always-ensure t)

   #+END_SRC

** Benchmarking startuo time
   #+BEGIN_SRC elisp
     ;;(use-package esup)
   #+END_SRC

** Which key
  Showing key bindings in a minor mode might seem like a good idea.
  The window will be shown when I enter an incomplete command and wait for a second.
  #+BEGIN_SRC elisp
	    (use-package which-key
	      :ensure t)
	(require 'which-key)
	    ;; add minor mode to show help
	    (which-key-mode)
	    ;; slide in from right side if there is enough space there ;
	    (which-key-setup-side-window-right)

	(which-key-setup-minibuffer)

	(setq which-key-show-early-on-C-h t)
	;; but if possible, use the minibuffer
  #+END_SRC

* Startup
  
** Dashboard
   #+begin_src elisp
     (use-package nerd-icons)

     (use-package dashboard
       :ensure t
       :config
       ;;(dashboard-setup-startup-hook)
       (setq initial-buffer-choice (lambda () (get-buffer-create dashboard-buffer-name)))
       (setq dashboard-item-shortcuts '((recents   . "r")
				      (bookmarks . "m")
				      (projects  . "p")
				      (agenda    . "a")
				      (registers . "e")))
       (setq dashboard-item-names '(("Recent Files:"               . "Recently opened files:")
				  ("Agenda for today:"           . "Today's agenda:")
				  ("Agenda for the coming week:" . "Agenda:")))
       (setq dashboard-display-icons-p t)     ; display icons on both GUI and terminal
     (setq dashboard-icon-type 'nerd-icons)) ; use `nerd-icons' package

   #+end_src
* Hydra
  #+begin_src elisp
    (use-package hydra)
  #+end_src   
* EXWM
  A very nice window manager for keyboard driven working.
** Basic exwm setup
*** Install dependencies
    #+BEGIN_SRC elisp
	    (cond
	     ((not (string-equal system-type "darwin"))
	      (progn
		(use-package exwm)
		;;(require 'exwm)
		)))

    #+END_SRC


** Helper function
   #+begin_src elisp
     (defun efs/exwm-update-class ()
     (exwm-workspace-rename-buffer exwm-class-name))

     (defun efs/exwm-update-title ()
       (pcase exwm-class-name
	 ("Google-chrome" (exwm-workspace-rename-buffer (format "Chrome %s" exwm-title)))))

     (defun efs/configure-window-by-class ()
       (interactive)
       (pcase exwm-class-name
	 ("Chrome" (exwm-workspace-move-window 1))
	 ("Firefox" (exwm-workspace-move-window 2))
	 ("webstorm" (exwm-workspace-move-window 0))
	 ("thunderbird" (exwm-workspace-move-window 4))
	 ("TelegramDesktop" (exwm-workspace-move-window 3))))

     (defun efs/polybar-exwm-workspace ()
       (pcase exwm-workspace-current-index
	 (0 "0--messages")
	 (1 "1--eternl")
	 (2 "2--work")
	 (3 "3--browse")
	 (4 "4-misc")
	 (5 "5-misc")))

     (defun cb0/toggle-polybar ()
       (interactive)
       (start-process-shell-command "polybar-msg" nil "polybar-msg cmd toggle"))

     (defun efs/send-polybar-hook (module-name hook-index)
       (start-process-shell-command "polybar-msg" nil (format "polybar-msg hook %s %s" module-name hook-index)))

     (defun efs/send-polybar-hook (module-name hook-index)
       (let ((command (format "polybar-msg hook %s %s" module-name hook-index)))
	 (start-process-shell-command "polybar-msg" nil command)))

     (defun efs/send-polybar-exwm-workspace ()
       (efs/send-polybar-hook "exwm-workspace" 1))

     ;; Update panel indicator when workspace changes
     (add-hook 'exwm-workspace-switch-hook #'efs/send-polybar-exwm-workspace)

     (defun efs/run-in-background (command)
       (let ((command-parts (split-string command "[ ]+")))
	 (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))

   #+end_src
   
** Window looks and theme
   #+begin_src elisp
     ;; (set-frame-parameter (selected-frame) 'alpha '(90 . 90))
     ;; (add-to-list 'default-frame-alist '(alpha . (90 . 90)))
     ;; (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
     ;; (add-to-list 'default-frame-alist '(fullscreen . maximized))

     (display-battery-mode 1)
     
     (setq display-time-day-and-date t)
     (setq display-time-format "%H:%M")
     (display-time-mode 1)

     (exwm-input-set-key (kbd "s-SPC") 'counsel-linux-app)
     (exwm-input-set-key (kbd "s-f") 'exwm-layout-toggle-fullscreen)

   #+end_src

** Configure WM
   #+begin_src elisp
     (setq exwm-workspace-number 5)

     ;; use line mode on startup
     (setq exwm-manage-configurations '((t line-mode t)))

     ;; All buffers created in EXWM mode are named "*EXWM*". You may want to
     ;; change it in `exwm-update-class-hook' and `exwm-update-title-hook', which
     ;; are run when a new X window class name or title is available.  Here's
     ;; some advice on this topic:
     ;; + Always use `exwm-workspace-rename-buffer` to avoid naming conflict.
     ;; + For applications with multiple windows (e.g. GIMP), the class names of
					     ;    all windows are probably the same.  Using window titles for them makes
     ;;   more sense.
     ;; In the following example, we use class names for all windows except for
     ;; Java applications and GIMP.
     (add-hook 'exwm-update-class-hook
	       (lambda ()
		 (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
			     (string= "gimp" exwm-instance-name))
		   (exwm-workspace-rename-buffer exwm-class-name))))

     (add-hook 'exwm-update-title-hook
	       (lambda ()
		 (when (or (not exwm-instance-name)
			   (string-prefix-p "sun-awt-X11-" exwm-instance-name)
			   (string= "gimp" exwm-instance-name))
		   (exwm-workspace-rename-buffer exwm-title))))

     (add-hook 'exwm-update-class-hook #'efs/exwm-update-class)
     (add-hook 'exwm-update-title-hook #'efs/exwm-update-title)
     (add-hook 'exwm-manage-finish-hook #'efs/configure-window-by-class)

     ;;(exwm-config-example)
     (exwm-enable)

     (setq exwm-input-simulation-keys
	   '(([?\C-b] . [left])
	     ([?\C-f] . [right])
	     ([?\C-p] . [up])
	     ([?\C-n] . [down])
	     ([?\C-a] . [home])
	     ([?\C-e] . [end])
	     ([?\M-v] . [prior])
	     ([?\C-v] . [next])
	     ([?\C-d] . [delete])
	     ([?\C-k] . [S-end delete])))


     ;;using xim input
     ;; ;(require 'exwm-xim)

     ;; ;(exwm-xim-enable)
     ;; ;;(exwm-xim--exit)

     (setq exwm-input-prefix-keys
	   '(?\C-x
	     ?\C-u
	     ?\C-h	   
	     ?\M-x
	     ?\M-`
	     ?\M-&
	     ?\M-:
	     ?\C-\\
	     ?\C-\M-j
	     ?\C-\ ))

     ;; use Ctrl + \ to switch input method
     (push ?\C-\\ exwm-input-prefix-keys)

   #+end_src
** Modify exwm startup
   #+begin_src elisp
	;;from https://config.daviwil.com/desktop
	;;Hide the modeline on all X windows
	(add-hook 'exwm-floating-setup-hook
		  (lambda ()
		    (exwm-layout-hide-mode-line)))

     ;; Ctrl+Q will enable the next key to be sent directly
     (define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)

   #+end_src

** Window handling
   I want to be able to switch to a buffer even if it is not in the current workspace.
   This will move a buffer to my current workspace when I select the buffer.
   #+begin_src elisp
     (cond
      ((not (string-equal system-type "darwin"))
       (progn
	 (setq exwm-workspace-show-all-buffers t)
	 (setq exwm-layout-show-all-buffers t))))

   #+end_src
** Hide minibuffer and echo area
   Get more space by hiding the echo area and the mini buffer when not required.
   #+begin_src elisp
     ;; (cond
     ;;  ((not (string-equal system-type "darwin"))
     ;;   (progn (setq exwm-workspace-minibuffer-position 'bottom)
     ;; 	 (setq exwm-workspace-display-echo-area-timeout 5)

     ;; 	 )))

   #+end_src
** Screen resolution

   #+begin_src elisp
     (require 'exwm-randr)
     ;;(exwm-randr-enable)

     (start-process-shell-command "xrandr" nil "")
   #+end_src
** Polybar
   #+begin_src elisp

     (defvar efs/polybar-process nil
       "Holds the process of the running Polybar instance, if any")

     (defun efs/kill-panel ()
       (interactive)
       (when efs/polybar-process
	 (ignore-errors
	   (kill-process efs/polybar-process)))
       (setq efs/polybar-process nil))

     (defun efs/start-panel ()
       (interactive)
       (efs/kill-panel)
       (setq efs/polybar-process (start-process-shell-command "polybar" nil "polybar panel")))

   #+end_src
*** Init Hook
   #+begin_src elisp

     (defun efs/exwm-init-hook ()

       (message "Calling exwm-init-hook")
       ;; Make workspace 1 be the
       ;; one where we land at startup
       (exwm-workspace-switch-create 1)

       ;; Open eshell by default
       ;;(eshell)
       (efs/start-panel)
       ;; (efs/kill-panel)
       ;;(efs/run-in-background "dunst")

       ;; Launch apps that will run in the background
       (efs/run-in-background "nm-applet")
     )

     (add-hook 'efs/exwm-init-hook #'efs/after-exwm-init)
     (efs/start-panel)

     ;; (efs/run-in-background "pavucontrol")	
     ;; (efs/run-in-background "blueman-applet")
   #+end_src
*** Desktop environment management
   #+begin_src elisp
     (add-to-list 'load-path "~/.emacs.d/lib/desktop-environment/")
     (require 'desktop-environment)

     (use-package desktop-environment
       :after exwm
       :config (desktop-environment-mode)
       :custom
       (desktop-environment-brightness-small-increment "2%+")
       (desktop-environment-brightness-small-decrement "2%-")
       (desktop-environment-brightness-normal-increment "5%+")
       (desktop-environment-brightness-normal-decrement "5%-")
       (desktop-environment-screenshot-command "flameshot gui"))



     ;; ;; This needs a more elegant ASCII banner
     ;; (defhydra hydra-exwm-move-resize (:timeout 4)
     ;;   "Move/Resize Window (Shift is bigger steps, Ctrl moves window)"
     ;;   ("j" (lambda () (interactive) (exwm-layout-enlarge-window 10)) "V 10")
     ;;   ("J" (lambda () (interactive) (exwm-layout-enlarge-window 30)) "V 30")
     ;;   ("k" (lambda () (interactive) (exwm-layout-shrink-window 10)) "^ 10")
     ;;   ("K" (lambda () (interactive) (exwm-layout-shrink-window 30)) "^ 30")
     ;;   ("h" (lambda () (interactive) (exwm-layout-shrink-window-horizontally 10)) "< 10")
     ;;   ("H" (lambda () (interactive) (exwm-layout-shrink-window-horizontally 30)) "< 30")
     ;;   ("l" (lambda () (interactive) (exwm-layout-enlarge-window-horizontally 10)) "> 10")
     ;;   ("L" (lambda () (interactive) (exwm-layout-enlarge-window-horizontally 30)) "> 30")
     ;;   ("C-j" (lambda () (interactive) (exwm-floating-move 0 10)) "V 10")
     ;;   ("C-S-j" (lambda () (interactive) (exwm-floating-move 0 30)) "V 30")
     ;;   ("C-k" (lambda () (interactive) (exwm-floating-move 0 -10)) "^ 10")
     ;;   ("C-S-k" (lambda () (interactive) (exwm-floating-move 0 -30)) "^ 30")
     ;;   ("C-h" (lambda () (interactive) (exwm-floating-move -10 0)) "< 10")
     ;;   ("C-S-h" (lambda () (interactive) (exwm-floating-move -30 0)) "< 30")
     ;;   ("C-l" (lambda () (interactive) (exwm-floating-move 10 0)) "> 10")
     ;;   ("C-S-l" (lambda () (interactive) (exwm-floating-move 30 0)) "> 30")
     ;;   ("f" nil "finished" :exit t))



     ;; Workspace switching
     (setq exwm-input-global-keys	   
	 `(;; reset to line mode (C-c C-k switch to char mode)
	   ([?\s-\C-r] . exwm-reset)
	   ;; switch workspaces
	   ([?\s-w] . exwm-workspace-switch)
	   ;; hydro to rresize windows
	   ;;([?\s-r] . hydra-exwm-move-resize/body)
	   ;; quick jump to current directory
	   ([?\s-e] . dired-jump)
	   ;; quick jump to home directory
	   ([?\s-E] . (lambda () (interactive) (dired "~")))

	   ([?\s-Q] . (lambda () (interactive) (kill-buffer)))
	   ([?\s-`] . (lambda () (interactive) (exwm-workspace-switch-create 0)))
	   ([?\s-&] . (lambda (command)
			(interactive (list (read-shell-command "$ ")))
			(start-process-shell-command command nil command)))
	   ([?\C-\s-l] . (lambda ()
			   (interactive)
			   (start-process "" nil "/usr/bin/slock")))
	   ,@(mapcar (lambda (i)
		       `(,(kbd (format "s-%d" i)) .
			 (lambda ()
			   (interactive)
			   (exwm-workspace-switch-create ,i))))
		     (number-sequence 0 9))))

     ;; setting these in exwm-input-global-keys does not work
     (exwm-input-set-key (kbd "s-<left>") 'windmove-left)
     (exwm-input-set-key (kbd "s-<right>") 'windmove-right)
     (exwm-input-set-key (kbd "s-<up>") 'windmove-up)
     (exwm-input-set-key (kbd "s-<down>") 'windmove-down)

     (exwm-input-set-key (kbd "S-s-<down>") 'windmove-swap-states-down)
     (exwm-input-set-key (kbd "S-s-<up>") 'windmove-swap-states-up)
     (exwm-input-set-key (kbd "S-s-<left>") 'windmove-swap-states-left)
     (exwm-input-set-key (kbd "S-s-<right>") 'windmove-swap-states-right)

     ;; (exwm-enable)
   #+end_src

*** Network manager
   #+begin_src elisp
     (use-package enwc)
     ;;(require 'enwc)
     (setq enwc-default-backend 'nm)
     ;;(condition-case nil			
     ;;    (enwc)
     ;;  (error nil))
   #+end_src



*** Enable exwm
    Then finally enable exwm
    #+BEGIN_SRC elisp
      ;;(exwm-enable)
    #+END_SRC    

** Logout
   #+begin_src elisp
(defun exwm-logout ()
  (interactive)
  (recentf-save-list)
  (save-some-buffers))
   #+end_src

* Keyboard changes
** Rebind capslock to control
   #+BEGIN_SRC elisp
     (start-process-shell-command "xmodmap" nil "setxkbmap -option ctrl:nocaps")
   #+END_SRC

*** Ask before qutting emacs
   Especially when running exwm, closing the current emacs would close the whole window manager.
   To cope with this, just ask before doing it.
   #+BEGIN_SRC elisp
     (defun ask-before-closing ()
       "Close only if y was pressed."
       (interactive)
       (if (y-or-n-p (format "Are you sure you want to close this frame? "))
	   (save-buffers-kill-emacs)                                                                                            
	 (message "Canceled frame close")))

     (when (daemonp)
       (global-set-key (kbd "C-x C-c") 'ask-before-closing))
   #+END_SRC

*** File for customizations) from within emacs
    If we customize variables we want to save those changes to `custom.el` file.
    #+BEGIN_SRC emacs-lisp
      (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
    #+END_SRC

* Helper Functions
  Here I define functions that should help me in every mode.
  Small tools to make the life more easy.
** Increase Number at point
   #+BEGIN_SRC elisp
     (defun my-increment-number-decimal (&optional arg)
       "Increment the number forward from point by 'arg'."
       (interactive "p*")
       (save-excursion
	 (save-match-data
	   (let (inc-by field-width answer)
	     (setq inc-by (if arg arg 1))
	     (skip-chars-backward "0123456789")
	     (when (re-search-forward "[0-9]+" nil t)
	       (setq field-width (- (match-end 0) (match-beginning 0)))
	       (setq answer (+ (string-to-number (match-string 0) 10) inc-by))
	       (when (< answer 0)
		 (setq answer (+ (expt 10 field-width) answer)))
	       (replace-match (format (concat "%0" (int-to-string field-width) "d")
				      answer)))))))

     (defun my-decrement-number-decimal (&optional arg)
       (interactive "p*")
       (let (inc-by)
	 (setq inc-by (if arg arg 1))
	 (my-increment-number-decimal (* -1 inc-by))
	 ))

     (global-set-key (kbd "M-+") 'my-increment-number-decimal)
     (global-set-key (kbd "M-_") 'my-decrement-number-decimal)
   #+END_SRC
** Copy filename of current buffer to clipboard
   #+BEGIN_SRC elisp
     (defun copy-file-name-to-clipboard ()
       "Copy the current buffer file name to the clipboard."
       (interactive)
       (let ((filename (if (equal majournalor-mode 'dired-mode)
                           default-directory
                         (buffer-file-name))))
         (when filename
           (kill-new filename)
           (message "Copied buffer file name '%s' to the clipboard." filename))))

   #+END_SRC    
* Customize my theme:
** Line Wrapping
   I really like when long lines are wrapped so I don't have to scroll to the right.
   The [[https://www.emacswiki.org/emacs/LineWrap][emacs wiki]] has different options for that. I for now will use `[[https://www.emacswiki.org/emacs/VisualLineMode][visual-line-mode]]`.
   #+BEGIN_SRC elisp
     (global-visual-line-mode 1)
   #+END_SRC

** Remove all interface distractions:
   I don't like the scrollbar, menu and toolbar.
   #+BEGIN_SRC elisp
     (fringe-mode 1)
     (menu-bar-mode -1)
     (scroll-bar-mode -1)
     (tool-bar-mode -1)
   #+END_SRC
** Fullscreen
   #+BEGIN_SRC elisp
     (global-set-key [f11] 'toggle-frame-fullscreen)
   #+END_SRC
** Zen Burn theme
   #+BEGIN_SRC elisp
     (use-package zenburn-theme)
     (load-theme 'zenburn t)
   #+END_SRC
** Spaceline
   Spaceline theme
   #+BEGIN_SRC elisp
     (use-package spaceline)
     ;;(package-require 'spaceline-config)
     (spaceline-spacemacs-theme)
   #+END_SRC

* Code Handling
** Region expanding
   #+begin_src elisp
     (use-package expand-region
       :config

     (global-set-key (kbd "C-]") 'er/expand-region))
     
   #+end_src
** Commenting of code
   When commenting code I use `M-,` to do this
*** Single line
    #+BEGIN_SRC emacs-lisp
      (defun comment-or-uncomment-region-or-line ()
	"Comments or uncomments the region or the current line if there's no active region."
	(interactive)
	(let (beg end)
	  (if (region-active-p)
	      (setq beg (region-beginning) end (region-end))
	    (setq beg (line-beginning-position) end (line-end-position)))
	  (comment-or-uncomment-region beg end)
	  (next-line)))

      (global-set-key (kbd "M-,") 'comment-or-uncomment-region-or-line)
    #+END_SRC
*** Regions
    #+BEGIN_SRC emacs-lisp
      ;; (global-set-key (kbd "C-x C-;") 'comment-region)
      ;; (global-set-key (kbd "C-x C-:") 'uncomment-region)
    #+END_SRC

* File Handling
  
** Recentf
   To enable me to quickly navigate to my recent files, this mode is recommended.
   #+begin_src elisp
     (recentf-mode 1)
     (setq recentf-max-menu-items 25)
     (setq recentf-max-saved-items 25)
     (global-set-key  (kbd "C-x C-r") 'recentf-open-files)
   #+end_src
* Session Management
** Desktop mode
   #+BEGIN_SRC emacs-lisp
     (use-package desktop)
     (desktop-save-mode 1)
     (setq history-length 250)
     ;(add-to-list 'desktop-globals-to-save 'file-name-history)

     (defun my-desktop-save ()
       (interactive)
       ;; Don't call desktop-save-in-desktop-dir, as it prints a message.
       (if (eq (desktop-owner) (emacs-pid))
	   (desktop-save desktop-dirname)))
     (add-hook 'auto-save-hook 'my-desktop-save)

     ;;(desktop-read)

  #+END_SRC
* Autocomplete
  #+BEGIN_SRC emacs-lisp
    (use-package company)
    (add-hook 'after-init-hook 'global-company-mode)
  #+END_SRC
* Key Management
** Set default font size
   #+begin_src elisp

      (text-scale-set 4)
   #+end_src
** [#B] Font size handling
   In/Decrease the font size with `C-+` and `C--`
   #+BEGIN_SRC emacs-lisp
     (define-key global-map (kbd "C-+") 'text-scale-increase)
     (define-key global-map (kbd "C--") 'text-scale-decrease)
     (define-key global-map (kbd "C-=") 'text-scale-decrease)
   #+END_SRC
** Window Handling
*** Resize Windows
    In split mode I use `S-C` with arrow keys for resizing windows.
    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "S-C-<left>") 'shrink-window-horizontally)
      (global-set-key (kbd "S-C-<right>") 'enlarge-window-horizontally)
      (global-set-key (kbd "S-C-<up>") 'shrink-window)
      (global-set-key (kbd "S-C-<down>") 'enlarge-window)
    #+END_SRC
*** Jump between windows
    #+BEGIN_SRC emacs-lisp
      ;; Jump backwards between windows
      (defun other-window-backward (n)
	"Select Nth previous window."
	(interactive "p")
	(other-window (- n)))

      ;;bind switching between windows to SHIFT-UP/DOWN (super usefull!!!!)
      ;;does not work in org files, therefore use win-[UP/DOWN]
      (global-set-key [(shift down)] 'other-window)
      (global-set-key [(shift up)] 'other-window-backward)
    #+END_SRC

*** Zoom windows
    #+BEGIN_SRC emacs-lisp
      (use-package zoom-window)
      ;; ;;(setq zoom-window-use-elscreen t)
      (zoom-window-setup)

      (global-set-key (kbd "C-x C-z") 'zoom-window-zoom)
    #+END_SRC

* Tramp
** Clean up tramp connections
   When opening directories over tramp and not closing them manually, the minibuffer sometimes ask for a ssh pass while doing something completly different.
   This is because the directories are still open inside `ido-dir-file-cache`. Searching [[https://www.emacswiki.org/emacs/TrampMode#toc13][emacs wiki]] I found this snipper which will remove these connections from `ido-dir-file-cache`
   This conatains of a function for removing those buffers.
   #+BEGIN_SRC emacs-lisp
     (defun ido-remove-tramp-from-cache nil
       "Remove any TRAMP entries from `ido-dir-file-cache'.
         This stops tramp from trying to connect to remote hosts on emacs startup,
         which can be very annoying."
       (interactive)
       (setq ido-dir-file-cache
             (cl-remove-if
              (lambda (x)
                (string-match "/\\(rsh\\|ssh\\|telnet\\|su\\|sudo\\|sshx\\|krlogin\\|ksu\\|rcp\\|scp\\|rsync\\|scpx\\|fcp\\|nc\\|ftp\\|smb\\|adb\\):" (car x)))
              ido-dir-file-cache)))
     ;; redefine 'ido-kill-emacs-hook' so that cache is cleaned before being saved
     (defun ido-kill-emacs-hook ()
       (ido-remove-tramp-from-cache)
       (ido-save-history))
   #+END_SRC

* All the icons
  #+begin_src elisp
    (use-package all-the-icons
      :if (display-graphic-p))

    ;;(all-the-icons-completion-mode)
    ;;(add-hook 'marginalia-mode-hook #'all-the-icons-completion-marginalia-setup)
  #+end_src

* Counsel
  #+BEGIN_SRC emacs-lisp
    (use-package counsel)
    (global-set-key (kbd "C-x C-f") 'counsel-find-file)
    (use-package counsel
      :custom (counsel-linux-app-format-function #'counsel-linux-app-format-function-name-only))
  #+END_SRC

* Vertico
  I used to use ivy, but have seen [[https://youtu.be/d3aaxOqwHhI?si=-qnBNB9gz3gwo40K][vertico]] presentation here and liked it and want to try it aswell.

  #+begin_src elisp
     (use-package vertico
       :bind (:map vertico-map
		   ("C-j" . vertico-next)
		   ("C-k" . vertico-previous)
		   ("C-f" . vertico-exit)
		   ("<tab>" . vertico-insert)
		   ("<escape>" . minibuffer-keyboard-quit)
		   ("C-M-n" . vertico-next-group)
		   ("C-M-p" . vertico-previous-group)
		   :map minibuffer-local-map
		   ("M-h" . backward-kill-word))
       :custom
       (vertico-cycle t)
       (vertico-resize nil)
       :init
       (vertico-mode))



     ;; Persist history over Emacs restarts. Vertico sorts by history position.
     (use-package savehist
       :ensure t
       :init
       (savehist-mode))

     ;; A few more useful configurations...
     (use-package emacs
       :custom
       ;; Support opening new minibuffers from inside existing minibuffers.
       (enable-recursive-minibuffers t)
       ;; Emacs 28 and newer: Hide commands in M-x which do not work in the current
       ;; mode.  Vertico commands are hidden in normal buffers. This setting is
       ;; useful beyond Vertico.
       (read-extended-command-predicate #'command-completion-default-include-p)
       :init
       ;; Add prompt indicator to `completing-read-multiple'.
       ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
       (defun crm-indicator (args)
	 (cons (format "[CRM%s] %s"
		       (replace-regexp-in-string
			"\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
			crm-separator)
		       (car args))
	       (cdr args)))
       (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

       ;; Do not allow the cursor in the minibuffer prompt
       (setq minibuffer-prompt-properties
	     '(read-only t cursor-intangible t face minibuffer-prompt))
       (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode))

     (use-package marginalia
       :after vertico
       :ensure t
       :custom
       (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
       :init
       (marginalia-mode))

     ;; (use-package marginalia
     ;;   :ensure t
     ;;   :config
     ;;   (marginalia-mode))

     ;; from https://youtu.be/d3aaxOqwHhI?si=-qnBNB9gz3gwo40K
     ;; The `orderless' package lets the minibuffer use an out-of-order
     ;; pattern matching algorithm.  It matches space-separated words or
     ;; regular expressions in any order.  In its simplest form, something
     ;; like "ins pac" matches `package-menu-mark-install' as well as
     ;; `package-install'.  This is a powerful tool because we no longer
     ;; need to remember exactly how something is named.
     ;;
     ;; Note that Emacs has lots of "completion styles" (pattern matching
     ;; algorithms), but let us keep things simple.
     ;;
     ;; Further reading: https://protesilaos.com/emacs/dotemacs#h:7cc77fd0-8f98-4fc0-80be-48a758fcb6e2
     (use-package orderless
       :config
       (setq completion-styles '(orderless basic)
	     completion-category-overrides '((file (styles partial-completion)))))

     (use-package embark
       :ensure t

       :bind
       (("C-." . embark-act)         ;; pick some comfortable binding
	("C-;" . embark-dwim)        ;; good alternative: M-.
	("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

       :init

       ;; Optionally replace the key help with a completing-read interface
       (setq prefix-help-command #'embark-prefix-help-command)

       ;; Show the Embark target at point via Eldoc. You may adjust the
       ;; Eldoc strategy, if you want to see the documentation from
       ;; multiple providers. Beware that using this can be a little
       ;; jarring since the message shown in the minibuffer can be more
       ;; than one line, causing the modeline to move up and down:

       ;; (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
       ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

       :config

       ;; Hide the mode line of the Embark live/completions buffers
       (add-to-list 'display-buffer-alist
		    '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
		      nil
		      (window-parameters (mode-line-format . none)))))

  #+end_src
  
* consult
  #+begin_src elisp
    ;; ;; Consult users will also want the embark-consult package.
    (use-package embark-consult
      :ensure t ; only need to install it, embark loads it after consult if found
      :hook
      (embark-collect-mode . consult-preview-at-point-mode)
      :config
      (global-set-key (kbd "C-x b") 'consult-buffer)
      (global-set-key (kbd "C-x g") 'consult-git-grep)
      (global-set-key (kbd "C-x k") 'consult-ag)
      (global-set-key (kbd "C-x l") 'consult-locate))

    (use-package embark-org-roam)
  #+end_src
* Swiper
  Generic completion frontend
  #+BEGIN_SRC emacs-lisp
    ;;(use-package swiper)

    ;;(setq magit-completing-read-function 'ivy-completing-read)
    ;;(setq projectile-completion-system 'ivy)

    ;;(ivy-mode 1)
    ;;(ivy-mode -1)

    ;; (setq ivy-use-virtual-buffers t)
    ;; (global-set-key "\C-s" 'swiper)
    ;; (global-set-key (kbd "C-c C-r") 'ivy-resume)
    ;; (global-set-key (kbd "M-x") 'counsel-M-x)
    ;; (global-set-key (kbd "C-x C-f") 'counsel-find-file)
    ;; (global-set-key (kbd "<f1> f") 'counsel-describe-function)
    ;; (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
    ;; (global-set-key (kbd "<f1> l") 'counsel-load-library)
    ;; (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
    ;; (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
    ;; (global-set-key (kbd "C-c g") 'counsel-git)
    ;; (global-set-key (kbd "C-c j") 'counsel-git-grep)
    ;; (global-set-key (kbd "C-c k") 'counsel-ag)
    ;; (global-set-key (kbd "C-x l") 'counsel-locate)
    ;; (package-require 'helm-rhythmbox)
    ;;(global-set-key (kbd "C-S-o") 'counsel-rhythmbox)

    ;; (defun counsel ()
    ;;   "Elisp completion at point."
    ;;   (interactive)
    ;;   (let* ((bnd (bounds-of-thing-at-point 'symbol))
    ;;          (str (buffer-substring-no-properties (car bnd) (cdr bnd)))
    ;;          (candidates (all-completions str obarray))
    ;;          (ivy-height 7)
    ;;          (res (ivy-read (format "pattern (%s): " str)
    ;;                         candidates)))
    ;;     (when (stringp res)
    ;;       (delete-region (car bnd) (cdr bnd))
    ;;       (insert res))))


  #+END_SRC

* Org Mode
** Install and set custom things for org-mode
   :LOGBOOK:
   CLOCK: [2024-07-25 Do 22:33]
   :END:
   #+BEGIN_SRC emacs-lisp
						  ; Activate org-mode
	  (use-package org)

     ;; (require 'org-install)
	  ;; (use-package org-habit)
	  ;; (setq org-habit-preceding-days 7
	  ;; org-habit-following-days 1
	  ;; org-habit-graph-column 80
	  ;; org-habit-show-habits-only-for-today t
	  ;; org-habit-show-all-today t)
	  ;;(require 'ess-site)
	  ;; http://orgmode.org/guide/Activation.html#Activation

	  ;; The following lines are always needed.  Choose your own keys.
	  (add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))

	  ;; And add babel inline code execution
	  ;; babel, for executing code in org-mode.
	  (org-babel-do-load-languages
	   'org-babel-load-languages
	   ;; load all language marked with (lang . t).
	   '((C . t)
     ;;	(org . t)
	     (shell . t)))

	  ;; turn off "evaluate code question" in org-mode code blocks
	  (setq org-confirm-babel-evaluate nil)

	  ;; and some more org stuff
	  (setq org-list-allow-alphabetical t)

	  (define-key global-map "\C-cl" 'org-store-link)
	  (define-key global-map "\C-ca" 'org-agenda)
	  ;; add a timestamp when we close an item
	  (setq org-log-done 'note)
     (setq org-treat-insert-todo-heading-as-state-change t)
     (setq org-log-into-drawer t)
	  ;; include a closing note when close an todo item
	  ;; (setq org-log-done 'note)

	  ;;(global-set-key "\C-cl" 'org-store-link)
	  ;; (global-set-key "\C-cc" 'org-capture)
	  ;; (global-set-key "\C-ca" 'org-agenda)
	  ;; (global-set-key "\C-cb" 'org-iswitchb)
	  ;; (global-set-key (kbd "<S-i>") 'org-clock-in)
	  ;; (global-set-key (kbd "<S-o>") 'org-clock-out)
	  ;; (global-set-key (kbd "<S-g>") 'org-clock-goto)



	  (custom-set-variables
	   '(org-agenda-files (directory-files-recursively "~/sync/org/" "\\.org$")))
	   '(org-agenda-ndays 7)
	   '(org-deadline-warning-days 14)
	   '(org-agenda-show-all-dates t)
	   '(org-agenda-skip-deadline-if-done t)
	   '(org-agenda-skip-scheduled-if-done t)
	   '(org-agenda-start-on-weekday nil)
	   '(org-reverse-note-order t)
	   '(org-fast-tag-selection-single-key (quote expert))


	  (global-set-key "\C-cr" 'org-capture)

	  ;; Org Capture
	  ;; (setq org-capture-templates
	  ;; '(("t" "Todo" entry (file+headline (concat org-directory "/gtd.org") "Tasks")
	  ;; "* TODO %?\n %i\n")
	  ;; ("l" "Link" plain (file (concat org-directory "/links.org"))
	  ;; "- %?\n %x\n")))


	   ;; '(org-remember-templates
	     ;; (quote ((116 "* TODO %?\n  %u" "~/todo.org" "Tasks")
		  ;; (110 "* %u %?" "~/notes.org" "Notes"))))
	   ;; '(remember-annotation-functions (quote (org-remember-annotation)))
	  ;;  '(remember-handler-functions (quote (org-remember-handler))))

	  ;; (package-require 'org-ac)
	  ;; (package-require 'org-tempo)

	  ;; To save the clock history across Emacs sessions:
	  (setq org-clock-persist 'history)
	  (org-clock-persistence-insinuate)
	  (setq org-clock-continuously nil)

	  ;; we want some non standard todo types
	  (setq org-todo-keywords
		'((sequence
		   "TODO(t)" "NEED_FEEDBACK(f)" "|" "CANCELED(c)" "DONE(d)")))

	  (setq org-todo-keyword-faces
		'(("TODO" :background "red1" :foreground "black" :weight bold :box (:line-width 2 :style released-button))
		  ("NEED_FEEDBACK" :background "yellow" :foreground "black" :weight bold :box (:line-width 2 :style released-button))
		  ("DONE" :background "forest green" :weight bold :box (:line-width 2 :style released-button))
		  ("CANCELLED" :background "lime green" :foreground "black" :weight bold :box (:line-width 2 :style released-button))))

	  ;; dont ask when executing code
	  (setq org-confirm-babel-evaluate nil)

	  (defface org-block-begin-line
	    '((t (:underline "#A7A6AA" :foreground "#040404" :background "#9a9a9a")))
	    "Face used for the line delimiting the begin of source blocks.")

	  (defface org-block-background
	    '((t (:background "#4F4F4F")))
	    "Face used for the source block background.")

	  (defface org-block-end-line
	    '((t (:overline "#A7A6AA" :foreground "#000000" :background "#9a9a9a")))
	    "Face used for the line delimiting the end of source blocks.")

	  (setq org-completion-use-ido t)

	  (setq exec-path (append exec-path '("/usr/bin/mscgen")))

	  (defun do-org-show-all-inline-images ()
	    (interactive)
	    (org-display-inline-images t t))

	  ;; (add-hook 'org-ctrl-c-ctrl-c-hook (lambda () (org-display-inline-images)))
	  ;;(add-hook 'org-confirm-babel-evaluate-hook (lambda () (org-display-inline-images)))

	  (add-hook 'org-babel-after-execute-hook
		    (lambda ()
		      (condition-case nil
			  (org-display-inline-images)
			(error nil)))
		    'append)

	  ;; set so that each line has correct indent
	  (setq org-adapt-indentation t)

   #+END_SRC
*** Fixing the insertion of source blocks in emacs org > 9.2

    As written [[https://github.com/syl20bnr/spacemacs/issues/11798#issuecomment-454941024][here]] the short syntax '>s' + 'TAB' does not expand into a bable source code block.
    The next code block will fix this.

    #+begin_src emacs-lisp
	(when (version<= "9.2" (org-version))
	  (require 'org-tempo))
    #+end_src

** Super Agenda
   #+begin_src elisp
     ;; (use-package org-super-agenda)
     ;; (org-super-agenda-mode)
     ;; (let ((org-super-agenda-groups
     ;;        '(;; Each group has an implicit boolean OR operator between its selectors.
     ;; 	 (:name "Today"  ; Optionally specify section name
     ;; 		:time-grid t  ; Items that appear on the time grid
     ;; 		:todo "TODAY")  ; Items that have this TODO keyword
     ;; 	 (:name "Important"
     ;; 		;; Single arguments given alone
     ;; 		:tag "work"
     ;; 		:priority "A"))))
     ;;   (org-agenda nil "a"))
   #+end_src
*** Integrate radicale online calendar
    #+begin_src elisp
     (use-package org-caldav)
     (setq org-caldav-url "https://cal.0xcb0.com/")
     (setq org-caldav-calendar-id "cb0/53ba00fd-502f-8b48-c01d-bd339a3ef42a")
     (setq org-caldav-inbox "~/org/calendar.org")
     (setq org-caldav-files ())
     (setq org-icalendar-timezone "Europe/Berlin")

     (global-set-key (kbd "C-c y") 'org-caldav-sync)

   #+end_src
*** Configure calendar usage
    #+begin_src elisp
      (setq calendar-week-start-day 1)
      (setq diary-number-of-entries 14)
      (appt-activate t)

      (global-set-key (kbd "C-c c") 'calendar)
      ;; use the same diary file as the one from caldav
      (setq diary-file org-caldav-inbox)
    #+end_src
*** Show week number in calendar
    #+begin_src elisp
      (copy-face font-lock-constant-face 'calendar-iso-week-face)
      (set-face-attribute 'calendar-iso-week-face nil
			  :height 0.7)
      (setq calendar-intermonth-text
	    '(propertize
	      (format "%2d"
		      (car
		       (calendar-iso-from-absolute
			(calendar-absolute-from-gregorian (list month day year)))))
	      'font-lock-face 'calendar-iso-week-face))
    #+end_src
** WC
   [[https://github.com/bnbeckwith/wc-mode][org-wd]] is a minor mode for counting words.
   #+BEGIN_SRC emacs-lisp
     (use-package org-wc)

     ;; and run org-wc-display on a timer every time I go idle for 5 seconds
     (defun pc/display-org-wc-in-buffer ()
       "Calls org-wc-display in the buffer if timer is set."
       (when (timerp pc/org-wc-display-timer)
         (call-interactively 'org-wc-display)))

     (defun pc/setup-org-wc-display-timer ()
       "Function to setup a buffer local timer."
       (interactive)

       (defvar pc/org-wc-display-timer nil
         "Buffer-local timer.")

       (let ((buffer (current-buffer)))
         (setq pc/org-wc-display-timer
               (run-with-idle-timer 2 t 'pc/display-org-wc-in-buffer))))

     (defun pc/cancel-org-wc-display-timer ()
       "Cancel the timer once we are done."
       (interactive)
       (when (timerp pc/org-wc-display-timer)
         (cancel-timer pc/org-wc-display-timer)))

   #+END_SRC
** Customizations
*** Quick open homenotes
    As I use the file `homenotes.org` the most often, I set up a key binding to open it up very quickly.
    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-c o")
                      (lambda () (interactive) (find-file "~/sync/org/old/homenotes.org")))
    #+END_SRC
*** Increase refile level
    By default org-refile only shows top level entries. With inspiration taken from [[http://sachachua.com/blog/2015/02/learn-take-notes-efficiently-org-mode/][sachachua]] I will increase this level to 5.
    #+BEGIN_SRC emacs-lisp
      (setq org-refile-targets '((org-agenda-files . (:maxlevel . 5))))
    #+END_SRC
** Agenda
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-c a") 'org-agenda)
     (global-set-key (kbd "C-c c") 'org-capture)
   #+END_SRC

** Babel
*** Remote dir fix!
    When evaluation source blocks inside org mode I get the same error as [[https://lists.gnu.org/archive/html/emacs-orgmode/2016-01/msg00281.html][here]].
    There is a fix for this by [[http://www.howardism.org/Technical/Emacs/literate-devops.html#fn.2][Howard]] but it involves adjusting org-mode source code. As this might change when updating, I will use this solution, proposed by John Kitchin [[https://lists.gnu.org/archive/html/emacs-orgmode/2016-01/msg00321.html][here]].
    #+BEGIN_SRC emacs-lisp
      (setq temporary-file-directory "/tmp/")
    #+END_SRC
* Org Roam
** Installation
   #+begin_src elisp
     (use-package org-roam
       :ensure t
       :init
       (setq org-roam-v2-ack t)
       :custom
       (org-roam-directory "~/sync/org/org-roam")
       (org-roam-dailies-directory "journal/")
       (org-roam-completion-everywhere t)
       (org-roam-capture-templates
	'(("d" "default" plain
	   "%?"
	   :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
	   :unnarrowed t)
	  ("p" "project" plain "%?"
	   :if-new
	   (file+head "project-ideas/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: :projectIdea:\ncreated: <%<%Y-%m-%d %a %H:%M>>\n")
	   :immediate-finish t
	   :unnarrowed t)))

       (setq org-roam-dailies-capture-templates
	     '(("d" "default" entry "* %<%I:%M %p>: %?"
		:if-new (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n"))
	       ("j" "journal" entry
		"** <%<%Y-%m-%d %a %H:%M>>: %?"
		:if-new (file+head "%<%Y-%m-%d>.org"
				   "#+title: %<%Y-%m-%d>\n\n* <%Y-%m-%d %a %H:%M>\n")
		:unnarrowed t)
	       ("w" "work" entry
		"** %<%H:%M>"
		:if-new (file+head "work-%<%Y-%m-%d>.org"
				   "#+title: %<%Y-%m-%d>\n\n* Work journal\n")
		:unnarrowed t)
	       ))


       :bind (("C-c n l"   . org-roam-buffer-toggle)
	      ("C-c n f"   . org-roam-node-find)
	      ("C-c n i"   . org-roam-node-insert)
	      ("C-c n _"   . org-id-get-create)
	      ("C-c n a"   . org-roam-alias-add)
	      ("C-c n d"   . org-roam-dailies-goto-date)
	      ("C-c n c"   . org-roam-dailies-capture-today)
	      ("C-c n C r" . org-roam-dailies-capture-tomorrow)
	      ("C-c n I"   . org-roam-node-insert-immediate)
	      ("C-c n t"   . org-roam-dailies-goto-today)
	      ("C-c n y"   . org-roam-dailies-goto-yesterday)
	      ("C-c n r"   . org-roam-dailies-goto-tomorrow)
	      ("C-c n R"   . my/org-roam-refresh-agenda-list)	     
	      ("C-c n g"   . org-roam-graph)
	      :map org-mode-map
	      ("C-M-i"     . completion-at-point))
       :config

       (defun org-roam-node-insert-immediate (arg &rest args)
	 "Insert a ref to a new roam note at buffer position, without jumping to that buffer."
	 (interactive "P")
	 (let ((args (cons arg args))
	       (org-roam-capture-templates (list (append (car org-roam-capture-templates)
							 '(:immediate-finish t)))))
	   (apply #'org-roam-node-insert args)))

       (defun my/org-roam-filter-by-tag (tag-name)
	 "Check if a tag is part of a node tags"
	 (lambda (node)
	   (member tag-name (org-roam-node-tags node))))

       (defun my/org-roam-list-notes-by-tag (tag-name)
	 "Filter my roam node files by a tag name"
	 (mapcar #'org-roam-node-file
		 (seq-filter
		  (my/org-roam-filter-by-tag tag-name)
		  (org-roam-node-list))))

       (defun my/org-roam-refresh-agenda-list ()
	 "Refresh the org-agenda-files with all my tags that I want to include."
	 (interactive)
	 (setq org-agenda-files (directory-files-recursively "~/sync/org/" "\\.org$")))
       ;; (setq org-agenda-files (my/org-roam-list-notes-by-tag "work")))

       (org-roam-setup)
       (org-roam-db-autosync-mode))

   #+end_src

   #+RESULTS:
   : completion-at-point

* Org Habits
  #+begin_src elisp
    (add-to-list 'org-modules 'org-habit t)
    (setq org-habit-show-all-today t)
  #+end_src

* Anki
  #+begin_src elisp
    (use-package anki-editor
      :after org
      :config
      ; I like making decks
      (setq anki-editor-create-decks 't))
  #+end_src

* Magit
  The best git client available
** init magit
   #+BEGIN_SRC emacs-lisp
     ;; git and magit (Magit rules!!!!)
     ;; (require 'git)
     (use-package magit)
     (global-set-key (kbd "<f5>") 'magit-status)

     ;;taken from http://tullo.ch/articles/modern-emacs-setup/
     ;; (defadvice magit-status (around magit-fullscreen activate)
     ;;   "Make magit-status run alone in a frame."
     ;;   (window-configuration-to-register :magit-fullscreen)
     ;;   ad-do-it
     ;;   (delete-other-windows))

     (defun magit-quit-session ()
       "Restore the previous window configuration and kill the magit buffer."
       (interactive)
       (kill-buffer)
       (jump-to-register :magit-fullscreen))

     (define-key magit-status-mode-map (kbd "q") 'magit-quit-session)

     ;;magit update recommendation
     ;;Note from update: Before running Git, Magit by default reverts all unmodified buffers which visit files tracked in the current repository. This can potentially lead to dataloss so you might want to disable this by adding the following line to your init file:
     (setq magit-auto-revert-mode nil)

     ;;prevent magit update message 1.4
     ;;(setq magit-last-seen-setup-instructions "1.4.0")

     (setq magit-completing-read-function 'magit-ido-completing-read)
     ;; (package-require 'ido-ubiquitous)
     ;; (ido-ubiquitous-mode 1)
   #+END_SRC
** Magit Customization
   #+BEGIN_SRC elisp
     (defun magit-stash-clear (ref)
       "Remove all stashes saved in REF's reflog by deleting REF."
       (interactive (let ((ref (or (magit-section-value-if 'stashes) "refs/stash")))
		      (magit-confirm t (format "Drop all stashes in %s" ref))
		      (list ref)))
     (message "To prevent from dropping all stashes again, this was disabled!"))
   #+END_SRC

* secretaria
  #+BEGIN_SRC emacs-lisp
    ;; (use-package secretaria
		 ;; :config
		 ;; use this for getting a reminder every 30 minutes of those tasks scheduled
		 ;; for today and which have no time of day defined.
		 ;; (add-hook 'after-init-hook #'secretaria-today-unknown-time-appt-always-remind-me))
  #+END_SRC

* XML Processing
** reformat/pretty print xml
   As always in emacs, there are [[http://stackoverflow.com/questions/12492/pretty-printing-xml-files-on-emacs][multiple options]] for the task of reformating a xml.
*** build in sgml mode
    Here I use sgml mode with pretty print and my known key combination "Control+Shift+L" to reformat code.
    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-S-l") 'sgml-pretty-print)
    #+END_SRC
*** using external xmllint
    We could also use `xmllint` which "might" be more applicable for large xml (to be tested).
    #+BEGIN_SRC emacs-lisp
      (defun xmllint-region (&optional b e)
        (interactive "r")
        (shell-command-on-region b e "xmllint --format -" t))
      ;;(global-set-key (kbd "C-M-l") 'xmlling-region)
    #+END_SRC
* Multiple Coursors
** Key Configuration:
   #+BEGIN_SRC emacs-lisp
     (use-package multiple-cursors)
     (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
     (global-set-key (kbd "C->") 'mc/mark-next-like-this)
     (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
     (global-set-key (kbd "C-c C-<down>") 'mc/mark-all-like-this)


   #+END_SRC

