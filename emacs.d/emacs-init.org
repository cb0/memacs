* What is this file about ?
  :PROPERTIES:
  :ID:       d36b5190-f05e-48fa-a180-2d257e054d35
  :ROAM_ALIASES: "emacs init file - written in org-mode" "init file exwm"
  :END:
  This is my personal emacs configuration, +which I started all over on <2024-07-12 Fr> because I was fed up with problems in the old config.+ which I did use for a very long time.
** My Target
   With this file I want to configure emacs instances on arch and os x. Also exwm on arch.
* Personal Information
  If you need to contact me, connect to me on github and send me a message.
  I am no longer active on social media or any other site. Event though my profiles still exist.
  There will be a personal page in the future.
  
* Startup customizatio Start server
** Starting the emacs server from here.
   Notes on server. I do not use the server call `(server-start)` anymore, because systemd and emacs server with exwm running in client works for me ONLY.
* TODO elpaca
  Install from https://github.com/progfolio/elpaca

* Setup package install
  
** Default package source
   To be able to install packages inside of emacs, we need to make sure emacs knows where to get those packages from. Just like with any other package manager.
    #+BEGIN_SRC elisp
      (require 'package)

      (setq package-archives '(("melpa" . "http://melpa.org/packages/")
			       ("org" . "http://orgmode.org/elpa/")
			       ("elpa" . "http://elpa.gnu.org/packages/")
			       ( "jcs-elpa" . "https://jcs-emacs.github.io/jcs-elpa/packages/")))

	    (unless package-archive-contents
	      (package-refresh-contents))

      (require 'use-package)
      (setq use-package-always-ensure t)

    #+END_SRC

** VC Install
   #+begin_src elisp
     (cl-defun slot/vc-install (&key (fetcher "github") repo name rev backend)
       "Install a package from a remote if it's not already installed.
     This is a thin wrapper around `package-vc-install' in order to
     make non-interactive usage more ergonomic.  Takes the following
     named arguments:

     - FETCHER the remote where to get the package (e.g., \"gitlab\").
       If omitted, this defaults to \"github\".

     - REPO should be the name of the repository (e.g.,
       \"slotThe/arXiv-citation\".

     - NAME, REV, and BACKEND are as in `package-vc-install' (which
       see)."
       (let* ((url (format "https://www.%s.com/%s" fetcher repo))
	      (iname (when name (intern name)))
	      (pac-name (or iname (intern (file-name-base repo)))))
	 (unless (package-installed-p pac-name)
	   (package-vc-install url iname rev backend))))
   #+end_src

   #+RESULTS:

** Benchmarking startup time
   #+BEGIN_SRC elisp
     ;;(use-package esup)
   #+END_SRC

** Which key
  Showing key bindings in a minor mode might seem like a good idea.
  The window will be shown when I enter an incomplete command and wait for a second.
  #+BEGIN_SRC elisp
    (use-package which-key
      :ensure t)

    (require 'which-key)
    ;; add minor mode to show help
    (which-key-mode)
    ;; slide in from right side if there is enough space there ;
    (which-key-setup-side-window-right)

    (which-key-setup-minibuffer)

    (setq which-key-show-early-on-C-h t)
    ;; but if possible, use the minibuffer
  #+END_SRC

* Startup  
** Disable bell
   #+begin_src elisp
     (setq ring-bell-function 'ignore)
   #+end_src
** Dashboard
   #+begin_src elisp
     (use-package nerd-icons)

     (use-package dashboard
       :ensure t
       :config
       ;;(dashboard-setup-startup-hook)
       (setq initial-buffer-choice (lambda () (get-buffer-create dashboard-buffer-name)))
       (setq dashboard-item-shortcuts '((recents   . "r")
				      (bookmarks . "m")
				      (projects  . "p")
				      (agenda    . "a")
				      (registers . "e")))
       (setq dashboard-item-names '(("Recent Files:"               . "Recently opened files:")
				  ("Agenda for today:"           . "Today's agenda:")
				  ("Agenda for the coming week:" . "Agenda:")))
       (setq dashboard-display-icons-p t)     ; display icons on both GUI and terminal
     (setq dashboard-icon-type 'nerd-icons)) ; use `nerd-icons' package

   #+end_src
** Save history
   #+begin_src elisp
(savehist-mode 1)
   #+end_src
** Auto revert
   #+begin_src elisp
(global-auto-revert-mode)
   #+end_src
** Add highlight for current line
   #+begin_src elisp
     (add-hook 'prog-mode-hook #'hl-line-mode)
     (add-hook 'text-mode-hook #'hl-line-mode)
     (add-hook 'org-mode-hook #'hl-line-mode)
   #+end_src
** Line Numbers
   #+begin_src elisp
     (defun renz/display-relative-lines ()
       (setq display-line-numbers-width 3)
       (setq display-line-numbers 'relative))

     (add-hook 'prog-mode-hook #'renz/display-relative-lines)
     (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
     (add-hook 'text-mode-hook #'renz/display-relative-lines)
   #+end_src
* EPA
  Use the internal password prompt and no external tool
  #+begin_src elisp
    ;; (setenv "GPG_AGENT_INFO" nil)
  #+end_src
** TODO Auth Sources
   See https://www.reddit.com/r/emacs/comments/14xjcje/access_your_passwordmanager_from_emacs_on_linux/ and fix
   #+begin_src elisp
	  ;; (use-package dash)
	  ;; (use-package s)

	  ;; (add-to-list 'load-path "~/.emacs.d/keepass-auth-source")

	  ;; (require 'keepass-auth-source)

	  ;; (add-to-list 'auth-sources "~/sync/KP/Final-Framework.kdbx") 

	  ;; (setq auth-sources '((:source "~/.authinfo.gpg")))

	  ;; (require 'auth-source)

	  ;; (defun secrets-unlock-item (collection item)
	  ;;   "Unlock item labeled ITEM from collection labeled COLLECTION.
	  ;;  If successful, return the object path of the item."
	  ;;   (let ((item-path (secrets-item-path collection item)))
	  ;; 	 (unless (secrets-empty-path item-path)
	  ;; 	   (secrets-prompt
	  ;; 	    (cadr
	  ;; 	     (dbus-call-method
	  ;; 	      :session secrets-service secrets-path secrets-interface-service
	  ;; 	      "Unlock" `(:array :object-path ,item-path)))))
	  ;; 	 item-path))


	  ;; (defun secrets-get-secret (collection item)
	  ;;   "Return the secret of item labeled ITEM in COLLECTION.
	  ;; If there are several items labeled ITEM, it is undefined which
	  ;; one is returned.  If there is no such item, return nil.

	  ;; ITEM can also be an object path, which is used if contained in COLLECTION."

	  ;;   (let ((item-path (secrets-unlock-item collection item)))
	  ;; 	 (unless (secrets-empty-path item-path)
	  ;; 	   (dbus-byte-array-to-string
	  ;; 	    (nth 2
	  ;; 		 (dbus-call-method
	  ;; 		  :session secrets-service item-path secrets-interface-item
	  ;; 		  "GetSecret" :object-path secrets-session-path))))))

     ;; (setq exwm-manage-force-tiling nil)
     
	  ;; (require 'secrets nil t)
	  ;; (secrets-open-session)
	  ;; (secrets-get-secret "keyring" "test")




   #+end_src

   #+RESULTS:
   : auth-source
   
** EPA Custom
   Do load the custom encrypted setup as last item. If something goes wrong I can still
   #+begin_src elisp
     (require 'epa-file)

     (epa-file-enable)

     (setq custom-epa-file (expand-file-name "epa.el.gpg" user-emacs-directory))
     (load custom-epa-file)
   #+end_src

* Hydra
  #+begin_src elisp
    (use-package hydra)
  #+end_src   
* Path
  #+begin_src elisp
	  (add-to-list 'exec-path "~/.bun/bin/")
  #+end_src
* Shell in emacs
** MultiTerm
   #+begin_src elisp
     
   #+end_src
* Customize emacs itself
** Always follow a symlink without asking me
   #+begin_src elisp
     (setq vc-follow-symlinks t)
   #+end_src
** Symon
   To get some nice looking stats and free up my polybar, I want to try symon.
   I was inspired trying this after reading [[https://web.archive.org/web/20180509003117/https://ambrevar.bitbucket.io/emacs-eshell/]["eshell as my main shell"]].
   But I have to disable it, because of  [[https://github.com/zk-phi/symon/issues/44][a bug]] 
   #+begin_src elisp
     ;; (use-package symon
     ;;   :init
     ;;   (symon-mode))
#+end_src
** Manage system pacman
   #+begin_src elisp
     (use-package system-packages
       :custom
       (system-packages-package-manager 'pacman))
   #+end_src
** Process manager like top
   Taken from https://laurencewarne.github.io/emacs/programming/2022/12/26/exploring-proced.html
   #+begin_src elisp
     (use-package proced
       :ensure nil
       :commands proced
       :bind (("C-M-p" . proced))
       :custom
       (proced-auto-update-flag t)
       (proced-goal-attribute nil)
       (proced-show-remote-processes t)
       (proced-enable-color-flag t)
       (proced-format 'custom)
       :config
       (add-to-list
	'proced-format-alist
	'(custom user pid ppid sess tree pcpu pmem rss start time state (args comm)))
       (visual-line-mode))

   #+end_src
* Linux adjustments
  I want to control pacman and possibly other stuff from within emacs.
** Pacman
   #+begin_src elisp
     (use-package arch-packer)
   #+end_src
* EXWM
  A very nice window manager for keyboard driven working.
** Basic exwm setup
*** Install dependencies
    #+BEGIN_SRC elisp
      (cond
       ((not (string-equal system-type "darwin"))
	(progn
	  (use-package exwm)
	  ;;(require 'exwm)
	  )))

    #+END_SRC


** Helper function
   #+begin_src elisp
     (defun efs/exwm-update-class ()
     (exwm-workspace-rename-buffer exwm-class-name))

     (defun efs/exwm-update-title ()
       (pcase exwm-class-name
	 ("Google-chrome" (exwm-workspace-rename-buffer (format "Chrome %s" exwm-title)))))

     (defun efs/configure-window-by-class ()
       (interactive)
       (pcase exwm-class-name
	 ("Chrome" (exwm-workspace-move-window 1))
	 ("Firefox" (exwm-workspace-move-window 2))
	 ("webstorm" (exwm-workspace-move-window 3))
	 ("thunderbird" (exwm-workspace-move-window 4))
	 ("TelegramDesktop" (exwm-workspace-move-window 3))))

     (defun efs/polybar-exwm-workspace ()
       (pcase exwm-workspace-current-index
	 (0 "0-")
	 (1 "1-")
	 (2 "2-")
	 (3 "3-")
	 (4 "4-")
	 (5 "5")))

     (defun cb0/toggle-polybar ()
       (interactive)
       (start-process-shell-command "polybar-msg" nil "polybar-msg cmd toggle"))

     (defun efs/send-polybar-hook (module-name hook-index)
       (start-process-shell-command "polybar-msg" nil (format "polybar-msg hook %s %s" module-name hook-index)))

     (defun efs/send-polybar-hook (module-name hook-index)
       (let ((command (format "polybar-msg hook %s %s" module-name hook-index)))
	 (start-process-shell-command "polybar-msg" nil command)))

     (defun efs/send-polybar-exwm-workspace ()
       (efs/send-polybar-hook "exwm-workspace" 1))

     ;; Update panel indicator when workspace changes
     (add-hook 'exwm-workspace-switch-hook #'efs/send-polybar-exwm-workspace)

     (defun efs/run-in-background (command)
       (let ((command-parts (split-string command "[ ]+")))
	 (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))

   #+end_src
   
** Window looks and theme
   #+begin_src elisp
     ;; (set-frame-parameter (selected-frame) 'alpha '(90 . 90))
     ;; (add-to-list 'default-frame-alist '(alpha . (90 . 90)))
     ;; (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
     ;; (add-to-list 'default-frame-alist '(fullscreen . maximized))

     (display-battery-mode 1)

     (setq display-time-day-and-date t)
     (setq display-time-format "%H:%M")
     (display-time-mode 1)

     (exwm-input-set-key (kbd "s-SPC") 'counsel-linux-app)
     (exwm-input-set-key (kbd "s-f") 'exwm-layout-toggle-fullscreen)

   #+end_src

** Configure WM
   #+begin_src elisp
     (setq exwm-workspace-number 5)

     ;; use line mode on startup
     (setq exwm-manage-configurations '((t line-mode t)))

     ;; All buffers created in EXWM mode are named "*EXWM*". You may want to
     ;; change it in `exwm-update-class-hook' and `exwm-update-title-hook', which
     ;; are run when a new X window class name or title is available.  Here's
     ;; some advice on this topic:
     ;; + Always use `exwm-workspace-rename-buffer` to avoid naming conflict.
     ;; + For applications with multiple windows (e.g. GIMP), the class names of
					     ;    all windows are probably the same.  Using window titles for them makes
     ;;   more sense.
     ;; In the following example, we use class names for all windows except for
     ;; Java applications and GIMP.
     (add-hook 'exwm-update-class-hook
	       (lambda ()
		 (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
			     (string= "gimp" exwm-instance-name))
		   (exwm-workspace-rename-buffer exwm-class-name))))

     (add-hook 'exwm-update-title-hook
	       (lambda ()
		 (when (or (not exwm-instance-name)
			   (string-prefix-p "sun-awt-X11-" exwm-instance-name)
			   (string= "gimp" exwm-instance-name))
		   (exwm-workspace-rename-buffer exwm-title))))

     (add-hook 'exwm-update-class-hook #'efs/exwm-update-class)
     (add-hook 'exwm-update-title-hook #'efs/exwm-update-title)
     (add-hook 'exwm-manage-finish-hook #'efs/configure-window-by-class)

     ;;(exwm-config-example)
     (exwm-enable)

     (setq exwm-input-simulation-keys
	   '(([?\C-b] . [left])
	     ([?\C-f] . [right])
	     ([?\C-p] . [up])
	     ([?\C-n] . [down])
	     ([?\C-a] . [home])
	     ([?\C-e] . [end])
	     ([?\M-v] . [prior])
	     ([?\C-v] . [next])
	     ([?\C-d] . [delete])
	     ([?\C-k] . [S-end delete])))


     ;;using xim input
     (require 'exwm-xim)

     (exwm-xim-enable)
     ;; ;;(exwm-xim--exit)

     (setq exwm-input-prefix-keys
	   '(?\C-x
	     ?\C-u
	     ?\C-h	   
	     ?\M-x
	     ?\M-`
	     ?\M-&
	     ?\M-:
	     ?\C-\\
	     ?\C-\M-j
	     ?\C-\ ))

     ;; use Ctrl + \ to switch input method
     (push ?\C-\\ exwm-input-prefix-keys)

   #+end_src
** Modify exwm startup
   #+begin_src elisp
	;;from https://config.daviwil.com/desktop
	;;Hide the modeline on all X windows
	(add-hook 'exwm-floating-setup-hook
		  (lambda ()
		    (exwm-layout-hide-mode-line)))

     ;; Ctrl+Q will enable the next key to be sent directly
     (define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)

   #+end_src

** Window handling
   I want to be able to switch to a buffer even if it is not in the current workspace.
   This will move a buffer to my current workspace when I select the buffer.
   #+begin_src elisp
     (cond
      ((not (string-equal system-type "darwin"))
       (progn
	 (setq exwm-workspace-show-all-buffers t)
	 (setq exwm-layout-show-all-buffers t))))

   #+end_src
** COMMENT Resize of windows with mouse
   #+begin_src elisp
     ;; Allow resizing with mouse, of non-floating windows.
     (setq window-divider-default-bottom-width 3
	   window-divider-default-right-width 3)
     (window-divider-mode)
   #+end_src
** Hide minibuffer and echo area
   Get more space by hiding the echo area and the mini buffer when not required.
   #+begin_src elisp
     ;; (cond
     ;;  ((not (string-equal system-type "darwin"))
     ;;   (progn (setq exwm-workspace-minibuffer-position 'bottom)
     ;; 	 (setq exwm-workspace-display-echo-area-timeout 5)

     ;; 	 )))

   #+end_src
** Screen resolution

   #+begin_src elisp
     (require 'exwm-randr)
     ;;(exwm-randr-enable)

     (start-process-shell-command "xrandr" nil "")
   #+end_src
** Polybar
   #+begin_src elisp

     (defvar efs/polybar-process nil
       "Holds the process of the running Polybar instance, if any")

     (defun efs/kill-panel ()
       (interactive)
       (when efs/polybar-process
	 (ignore-errors
	   (kill-process efs/polybar-process)))
       (setq efs/polybar-process nil))

     (defun efs/start-panel ()
       (interactive)
       (efs/kill-panel)
       (setq efs/polybar-process (start-process-shell-command "polybar" nil "polybar panel")))

   #+end_src
*** Init Hook
   #+begin_src elisp

     (defun efs/exwm-init-hook ()

       (message "Calling exwm-init-hook")
       ;; Make workspace 1 be the
       ;; one where we land at startup
       (exwm-workspace-switch-create 1)

       ;; Open eshell by default
       ;;(eshell)

       (efs/start-panel)

       ;; (efs/kill-panel)
       ;;(efs/run-in-background "dunst")

       ;; Launch apps that will run in the background
       (efs/run-in-background "nm-applet")
     )

     (add-hook 'efs/exwm-init-hook #'efs/after-exwm-init)
     (efs/start-panel)

     ;; (efs/run-in-background "pavucontrol")
     (efs/run-in-background "blueman-applet")
   #+end_src
** Desktop environment management
  #+begin_src elisp
    (add-to-list 'load-path "~/.emacs.d/lib/desktop-environment/")
    (require 'desktop-environment)

    (use-package desktop-environment
      :after exwm
      :config (desktop-environment-mode)
      :custom
      (desktop-environment-brightness-small-increment "2%+")
      (desktop-environment-brightness-small-decrement "2%-")
      (desktop-environment-brightness-normal-increment "5%+")
      (desktop-environment-brightness-normal-decrement "5%-")
      (desktop-environment-screenshot-command "flameshot gui"))

    ;; ;; This needs a more elegant ASCII banner
    ;; (defhydra hydra-exwm-move-resize (:timeout 4)
    ;;   "Move/Resize Window (Shift is bigger steps, Ctrl moves window)"
    ;;   ("j" (lambda () (interactive) (exwm-layout-enlarge-window 10)) "V 10")
    ;;   ("J" (lambda () (interactive) (exwm-layout-enlarge-window 30)) "V 30")
    ;;   ("k" (lambda () (interactive) (exwm-layout-shrink-window 10)) "^ 10")
    ;;   ("K" (lambda () (interactive) (exwm-layout-shrink-window 30)) "^ 30")
    ;;   ("h" (lambda () (interactive) (exwm-layout-shrink-window-horizontally 10)) "< 10")
    ;;   ("H" (lambda () (interactive) (exwm-layout-shrink-window-horizontally 30)) "< 30")
    ;;   ("l" (lambda () (interactive) (exwm-layout-enlarge-window-horizontally 10)) "> 10")
    ;;   ("L" (lambda () (interactive) (exwm-layout-enlarge-window-horizontally 30)) "> 30")
    ;;   ("C-j" (lambda () (interactive) (exwm-floating-move 0 10)) "V 10")
    ;;   ("C-S-j" (lambda () (interactive) (exwm-floating-move 0 30)) "V 30")
    ;;   ("C-k" (lambda () (interactive) (exwm-floating-move 0 -10)) "^ 10")
    ;;   ("C-S-k" (lambda () (interactive) (exwm-floating-move 0 -30)) "^ 30")
    ;;   ("C-h" (lambda () (interactive) (exwm-floating-move -10 0)) "< 10")
    ;;   ("C-S-h" (lambda () (interactive) (exwm-floating-move -30 0)) "< 30")
    ;;   ("C-l" (lambda () (interactive) (exwm-floating-move 10 0)) "> 10")
    ;;   ("C-S-l" (lambda () (interactive) (exwm-floating-move 30 0)) "> 30")
    ;;   ("f" nil "finished" :exit t))



    ;; Workspace switching
    (setq exwm-input-global-keys	   
	`(;; reset to line mode (C-c C-k switch to char mode)
	  ([?\s-\C-r] . exwm-reset)
	  ;; switch workspaces
	  ([?\s-w] . exwm-workspace-switch)
	  ;; hydro to rresize windows
	  ;;([?\s-r] . hydra-exwm-move-resize/body)
	  ;; quick jump to current directory
	  ([?\s-e] . dired-jump)
	  ;; quick jump to home directory
	  ([?\s-E] . (lambda () (interactive) (dired "~")))

	  ([?\s-Q] . (lambda () (interactive) (kill-buffer)))
	  ([?\s-`] . (lambda () (interactive) (exwm-workspace-switch-create 0)))
	  ([?\s-&] . (lambda (command)
		       (interactive (list (read-shell-command "$ ")))
		       (start-process-shell-command command nil command)))
	  ([?\C-\s-l] . (lambda ()
			  (interactive)
			  (start-process "" nil "/usr/bin/slock")))
	  ,@(mapcar (lambda (i)
		      `(,(kbd (format "s-%d" i)) .
			(lambda ()
			  (interactive)
			  (exwm-workspace-switch-create ,i))))
		    (number-sequence 0 9))))

    ;; setting these in exwm-input-global-keys does not work
    (exwm-input-set-key (kbd "s-<left>") 'windmove-left)
    (exwm-input-set-key (kbd "s-<right>") 'windmove-right)
    (exwm-input-set-key (kbd "s-<up>") 'windmove-up)
    (exwm-input-set-key (kbd "s-<down>") 'windmove-down)

    (exwm-input-set-key (kbd "S-s-<down>") 'windmove-swap-states-down)
    (exwm-input-set-key (kbd "S-s-<up>") 'windmove-swap-states-up)
    (exwm-input-set-key (kbd "S-s-<left>") 'windmove-swap-states-left)
    (exwm-input-set-key (kbd "S-s-<right>") 'windmove-swap-states-right)

    ;; (exwm-enable)
  #+end_src

** Network manager
  #+begin_src elisp
    (use-package enwc)
    ;;(require 'enwc)
    (setq enwc-default-backend 'nm)
    ;;(condition-case nil			
    ;;    (enwc)
    ;;  (error nil))
  #+end_src


** Fix Focus Problem
   Switching workspaces, the x window on the new workspace sometimes does not get the focus back.
   This seems to help solve this issue.
   From: https://github.com/emacs-exwm/exwm/issues/18#issuecomment-2019410008
   #+begin_src elisp
     (advice-add #'exwm-layout--hide
		 :after (lambda (id)
			  (with-current-buffer (exwm--id->buffer id)
			    (setq exwm--ewmh-state
				  (delq xcb:Atom:_NET_WM_STATE_HIDDEN exwm--ewmh-state))
			    (exwm-layout--set-ewmh-state id)
			    (xcb:flush exwm--connection))))
   #+end_src
** Enable exwm
   This is done in my profile file

** Logout
   #+begin_src elisp
     (defun exwm-logout ()
       (interactive)
       (recentf-save-list)
       (save-some-buffers))
   #+end_src

* Keyboard changes
** Rebind capslock to control
   #+BEGIN_SRC elisp
     (start-process-shell-command "xmodmap" nil "setxkbmap -layout us -option ctrl:nocaps")
   #+END_SRC

*** Ask before qutting emacs
   Especially when running exwm, closing the current emacs would close the whole window manager.
   To cope with this, just ask before doing it.
   #+BEGIN_SRC elisp
     (defun ask-before-closing ()
       "Close only if y was pressed."
       (interactive)
       (if (y-or-n-p (format "Are you sure you want to close this frame? "))
	   (save-buffers-kill-emacs)                                                                                            
	 (message "Canceled frame close")))

     (when (daemonp)
       (global-set-key (kbd "C-x C-c") 'ask-before-closing))
   #+END_SRC

*** File for customizations) from within emacs
    If we customize variables we want to save those changes to `custom.el` file.
    #+BEGIN_SRC emacs-lisp
      (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
    #+END_SRC

* Helper mode
  Here I define functions that should help me in every mode.
  Small tools to make the life more easy.
** Increase Number at point
   #+BEGIN_SRC elisp
     (defun my-increment-number-decimal (&optional arg)
       "Increment the number forward from point by 'arg'."
       (interactive "p*")
       (save-excursion
	 (save-match-data
	   (let (inc-by field-width answer)
	     (setq inc-by (if arg arg 1))
	     (skip-chars-backward "0123456789")
	     (when (re-search-forward "[0-9]+" nil t)
	       (setq field-width (- (match-end 0) (match-beginning 0)))
	       (setq answer (+ (string-to-number (match-string 0) 10) inc-by))
	       (when (< answer 0)
		 (setq answer (+ (expt 10 field-width) answer)))
	       (replace-match (format (concat "%0" (int-to-string field-width) "d")
				      answer)))))))

     (defun my-decrement-number-decimal (&optional arg)
       (interactive "p*")
       (let (inc-by)
	 (setq inc-by (if arg arg 1))
	 (my-increment-number-decimal (* -1 inc-by))
	 ))

     (global-set-key (kbd "M-+") 'my-increment-number-decimal)
     (global-set-key (kbd "M-_") 'my-decrement-number-decimal)
   #+END_SRC
** Copy filename of current buffer to clipboard
   #+BEGIN_SRC elisp
     (defun copy-file-name-to-clipboard ()
       "Copy the current buffer file name to the clipboard."
       (interactive)
       (let ((filename (if (equal majournalor-mode 'dired-mode)
			   default-directory
			 (buffer-file-name))))
	 (when filename
	   (kill-new filename)
	   (message "Copied buffer file name '%s' to the clipboard." filename))))

   #+END_SRC    
** Winner mode
   #+begin_src elisp
     (winner-mode 1)
   #+end_src
** Quickly jump to a window
   I would like to use ace-window but this does nort work with windows under exwm, so I stick to good old winum.
   #+begin_src elisp
     (use-package winum
       :config
       (winum-mode))
   #+end_src
* Customize my theme:
** Safe theme loading
   #+begin_src elisp
(defun safe-load-theme (theme)
  (interactive
   (list (intern (completing-read "Load theme: "
                                 (mapcar #'symbol-name
                                         (custom-available-themes))))))
  (mapc #'disable-theme custom-enabled-themes)
  (condition-case nil
      (load-theme theme t)
    (error (message "Could not load theme %s" theme))))
   #+end_src
** Line Wrapping
   I really like when long lines are wrapped so I don't have to scroll to the right.
   The [[https://www.emacswiki.org/emacs/LineWrap][emacs wiki]] has different options for that. I for now will use `[[https://www.emacswiki.org/emacs/VisualLineMode][visual-line-mode]]`.
   #+BEGIN_SRC elisp
     (global-visual-line-mode 1)
   #+END_SRC

** Remove all interface distractions:
   I don't like the scrollbar, menu and toolbar.
   #+BEGIN_SRC elisp
     (fringe-mode 1)
     (menu-bar-mode -1)
     (scroll-bar-mode -1)
     (tool-bar-mode -1)
   #+END_SRC
** Fullscreen
   #+BEGIN_SRC elisp
     (global-set-key [f11] 'toggle-frame-fullscreen)
   #+END_SRC
** COMMENT Darkula Theme
   #+begin_src elisp
     (use-package darcula-theme
       :ensure t

       :config
       (load-theme 'darcula))
       ;; ;; your preferred main font face here
       ;; (set-frame-font "Inconsolata-14"))

   #+end_src
** COMMENT Zen Burn theme
   #+BEGIN_SRC elisp
     ;; (use-package zenburn-theme)
     ;; (load-theme 'zenburn t)

     ;; (use-package modus-themes
     ;;    :init
     ;;    (load-theme 'modus-operandi t))

   #+END_SRC
** gruvbox-dark-hard!!!
   #+begin_src elisp
     ;; (use-package solarized-theme
     ;;   :config
     ;;      (load-theme 'solarized-light t))

     (safe-load-theme 'gruvbox-dark-hard)
   #+end_src
** Background image with transparency
   First install `feh` as system package and set bg image

   Then add the transparency
   #+begin_src elisp
     (defun efs/set-wallpaper ()
       (interactive)
       (start-process-shell-command
	"feh" nil  "feh --bg-scale ~/.config/background/DSCF6257.JPG"))
     (defun efs/set-wallpaper2 ()
       (interactive)
       (start-process-shell-command
	"feh" nil  "feh --bg-scale ~/.config/background/vintage-paper.jpg"))

     (efs/set-wallpaper)
     (efs/set-wallpaper2)

     ;; Define transparency variable (adjust the docstring as needed)
(defvar my-frame-transparency 60
  "Frame transparency level (0-100). 100 is fully opaque, 0 is transparent.")
     (set-frame-parameter (selected-frame) 'alpha (cons my-frame-transparency my-frame-transparency))
     (add-to-list 'default-frame-alist '(alpha . (cons my-frame-transparency my-frame-transparency)))
     (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
     (add-to-list 'default-frame-alist '(fullscreen . maximized))

     (add-hook 'exwm-after-startup-hook (lambda () (select-frame (exwm-frame))
					  (exwm-layout-toggle-fullscreen)))


   #+end_src
   
** Increase mode line height
   #+begin_src elisp
     (setq exwm-systemtray-height 32)
   #+end_src
** Spaceline
   Spaceline theme
   #+BEGIN_SRC elisp
     (use-package spaceline)
     ;;(package-require 'spaceline-config)
     (spaceline-spacemacs-theme)
   #+END_SRC
** Default font size
   #+begin_src elisp
     (defvar original-default-font-size (face-attribute 'default :height))

     (defun set-default-font-size (size)
       "Set the default font size to SIZE."
       (set-face-attribute 'default nil :height (* size 10)))

     (set-default-font-size 12)
   #+end_src
** Default minibuffer size
   #+begin_src elisp
	  (defun xah-setup-minibuffer ()
	    "make minibuffer use larger font size.
	  And possibly other settings.
	  Created: 2024-05-29
	  Version: 2024-05-29"
	    (text-scale-set 4))

     (add-hook 'minibuffer-mode-hook 'xah-setup-minibuffer )

     (add-hook 'temp-buffer-window-setup-hook 'xah-setup-minibuffer )

     ;;      (defvar original-minibuffer-font-size (face-attribute 'minibuffer-prompt :height))
     ;;      (defvar custom-minibuffer-font-size 120)
     ;;      (defvar use-custom-minibuffer-font-size nil)

     ;;      (defun toggle-minibuffer-font-size ()
     ;;        (interactive)
     ;;        (setq use-custom-minibuffer-font-size (not use-custom-minibuffer-font-size))
     ;;        (set-minibuffer-font-size (if use-custom-minibuffer-font-size
     ;; 				     custom-minibuffer-font-size
     ;; 				   (if  original-minibuffer-font-size
     ;; 				       original-minibuffer-font-size
     ;; 				     120))))

     ;;      (defun set-minibuffer-font-size (size)
     ;;        (set-face-attribute 'minibuffer-prompt nil :height size)
     ;;        (setq-default text-scale-mode-amount (log (/ size 100.0) 2))
     ;;        (add-hook 'minibuffer-setup-hook
     ;; 		 (lambda ()
     ;; 		   (text-scale-mode 1))))

     ;;      (toggle-minibuffer-font-size) ; Initial setup


   #+end_src

** Increase modline scale
   #+begin_src elisp
     (custom-set-faces
      '(mode-line ((t (:height 140)))))
   #+end_src
** Focus Mode
   This modes helps to concentrate on what is in front of me by dimming the surroundings.
   #+begin_src elisp
     (use-package focus
       :ensure
       :init
       (focus-mode))

   #+end_src
* Completion system
** COMMENT YaSnipper
   #+begin_src elisp
     (use-package yasnippet
       :config
       (setq yas-snippet-dirs
	     '("~/.emacs.d/snippets"))
       (yas-global-mode 1))
   #+end_src
** Orderless
   #+begin_src elisp
     (use-package orderless
       :custom
       (completion-styles '(orderless basic))
       (orderless-matching-styles
	'(orderless-literal
	  ;; orderless-prefixes
	  ;;orderless-initialism
	  orderless-regexp
	  ;;orderless-flex                       ; Basically fuzzy finding
	  ;; orderless-strict-leading-initialism
	  ;; orderless-strict-initialism
	  ;; orderless-strict-full-initialism
	  ;; orderless-without-literal          ; Recommended for dispatches instead
	  ))
       (completion-category-defaults nil)
       (partial-completion t)
       (completion-category-overrides '((file (styles basic partial-completion))))
	    ;; Make Orderless work with fewer characters
       (orderless-component-separator #'orderless-escapable-split-on-space)
       (completion-styles '(orderless basic)))

     (defun orderless-fast-dispatch (word index total)
       (and (= index 0) (= total 1) (length< word 4)
	    (cons 'orderless-literal-prefix word)))

     (orderless-define-completion-style orderless-fast
       (orderless-style-dispatchers '(orderless-fast-dispatch))
       (orderless-matching-styles '(orderless-literal orderless-regexp)))
   #+end_src

** Corfu
   #+begin_src elisp

	  ;;; Code:
     (use-package corfu
       :ensure t
       ;; Optional customizations
       :custom
       (corfu-cycle t)                 ; Allows cycling through candidates
       (corfu-auto t)                  ; Enable auto completion
       (corfu-auto-prefix 2)           ; Minimum length of prefix for completion
       (corfu-separator ?\s)          ;; Orderless field separator

       (corfu-auto-delay 0.5)            ; No delay for completion
       (corfu-popupinfo-delay '(0.5 . 0.2))  ; Automatically update info popup after that numver of seconds
       (corfu-preview-current 'insert) ; insert previewed candidate
       (corfu-preselect 'prompt)
       (corfu-on-exact-match nil)      ; Don't auto expand tempel snippets
       (corfu-auto t)
       (corfu-quit-no-match 'separator)
       (completion-styles '(orderless-fast basic))

       ;; Optionally use TAB for cycling, default is `corfu-complete'.
       :bind (:map corfu-map
		   ("M-SPC"      . corfu-insert-separator)
		   ("TAB"        . corfu-next)
		   ([tab]        . corfu-next)
		   ("S-TAB"      . corfu-previous)
		   ([backtab]    . corfu-previous)
		   ("S-<return>" . corfu-insert)
		   ("RET"        . corfu-insert))

       :init
       (global-corfu-mode)
       (corfu-history-mode)
       (corfu-popupinfo-mode) ; Popup completion info
       :config
       (add-hook 'eshell-mode-hook
		 (lambda () (setq-local corfu-quit-at-boundary t
					corfu-quit-no-match t
					corfu-auto nil)
		   (corfu-mode))
		 nil
		 t))

     (defun get-focused-monitor-geometry ()
       "Get the geometry of the monitor displaying the selected frame in EXWM."
       (let* ((monitor-attrs (frame-monitor-attributes))
	      (workarea (assoc 'workarea monitor-attrs))
	      (geometry (cdr workarea)))
	 (list (nth 0 geometry) ; X
	       (nth 1 geometry) ; Y
	       (nth 2 geometry) ; Width
	       (nth 3 geometry) ; Height
	       )))

     (defun advise-corfu-make-frame-with-monitor-awareness (orig-fun frame x y width height buffer)
       "Advise `corfu--make-frame` to be monitor-aware, adjusting X and Y according to the focused monitor."

       ;; Get the geometry of the currently focused monitor
       (let* ((monitor-geometry (get-focused-monitor-geometry))
	      (monitor-x (nth 0 monitor-geometry))
	      (monitor-y (nth 1 monitor-geometry))
	      (selected-frame-position (frame-position))
	      (selected-frame-x (car selected-frame-position))
	      (selected-frame-y (cdr selected-frame-position))
	      (new-x (+ monitor-x selected-frame-x x))
	      (new-y (+ monitor-y selected-frame-y y)))

	 ;; Call the original function with potentially adjusted coordinates
	 (funcall orig-fun frame new-x new-y width height buffer)))

     (advice-add 'corfu--make-frame :around #'advise-corfu-make-frame-with-monitor-awareness)

     ;; A few more useful configurations...
     (use-package emacs
       :custom
       ;; TAB cycle if there are only few candidates
       ;; (completion-cycle-threshold 3)

       ;; Enable indentation+completion using the TAB key.
       ;; `completion-at-point' is often bound to M-TAB.
       (tab-always-indent 'complete)

       ;; Emacs 30 and newer: Disable Ispell completion function. As an alternative,
       ;; try `cape-dict'.
       ;; @ToDo: enable once upgraded to emacs 30
       ;; (text-mode-ispell-word-completion nil)

       ;; Emacs 28 and newer: Hide commands in M-x which do not apply to the current
       ;; mode.  Corfu commands are hidden, since they are not used via M-x. This
       ;; setting is useful beyond Corfu.
       (read-extended-command-predicate #'command-completion-default-include-p))

     ;; Use Dabbrev with Corfu!
     (use-package dabbrev
       ;; Swap M-/ and C-M-/
       :bind (("M-/" . dabbrev-completion)
	      ("C-M-/" . dabbrev-expand))
       :config
       (add-to-list 'dabbrev-ignored-buffer-regexps "\\` ")
       ;; Since 29.1, use `dabbrev-ignored-buffer-regexps' on older.
       (add-to-list 'dabbrev-ignored-buffer-modes 'doc-view-mode)
       (add-to-list 'dabbrev-ignored-buffer-modes 'pdf-view-mode)
       (add-to-list 'dabbrev-ignored-buffer-modes 'tags-table-mode))

   #+end_src
   
** Cape
   This is a very expensi
   #+begin_src elisp
     ;; Add extensions

     ;; (use-package cape
     ;;   ;; Bind prefix keymap providing all Cape commands under a mnemonic key.
     ;;   ;; Press C-c p ? to for help.
     ;;   ;; :bind ("C-c p" . cape-prefix-map) ;; Alternative keys: M-p, M-+, ...
     ;;   ;; Alternatively bind Cape commands individually.
     ;;   :bind (("C-c p d" . cape-dabbrev)
     ;; 	 ("C-c p h" . cape-history))
     ;;   ("C-c p f" . cape-file)
     ;;   ;;        ...)
     ;;   :init
     ;;   ;; Add to the global default value of `completion-at-point-functions' which is
     ;;   ;; used by `completion-at-point'.  The order of the functions matters, the
     ;;   ;; first function returning a result wins.  Note that the list of buffer-local
     ;;   ;; completion functions takes precedence over the global list.
     ;;   (add-hook 'completion-at-point-functions #'cape-dabbrev)
     ;;   (add-hook 'completion-at-point-functions #'cape-file)
     ;;   (add-hook 'completion-at-point-functions #'cape-elisp-block)
     ;;   (add-hook 'completion-at-point-functions #'cape-dict)
     ;;   :custom
     ;;   (defalias 'cape-dabbrev+dict
     ;;     (cape-capf-super #'cape-dabbrev #'cape-dict))
     ;;   (add-to-list 'completion-at-point-functions #'cape-dabbrev+dict)
     ;;   ;; ...
     ;;   )
   #+end_src

* IDE
  :PROPERTIES:
  :ID:       bbda0aea-a425-4d53-9486-ebb183717561
  :ROAM_ALIASES: "IDE Settings in Emacs" "IDE Settings"
  :END:
  
** Languages I want to use
*** JSON
    #+begin_src elisp
      (use-package json-mode)
    #+end_src
*** Typescript
    #+begin_src elisp
      (use-package typescript-mode)
    #+end_src
*** Vue Mode
    #+begin_src elisp

      ;; (use-package vue-ts-mode
      ;;   :init (slot/vc-install :fetcher "github" :repo "8uff3r/vue-ts-mode"))


      ;; (add-to-list 'load-path (concat user-emacs-directory "vue-ts-mode"))
      ;; (require 'vue-ts-mode)

      (use-package vue-mode
	:mode "\\.vue\\'"
	:config
	(add-hook 'vue-mode-hook #'lsp-mode))

      ```

      ;; ;; 

      ;; ;; tmp fix as long as i cannot use 'vue-ts-mode
      ;; (add-to-list 'auto-mode-alist '("\\.vue\\'" . lsp-mode))

    #+end_src
** TODO Ts and more
   This needs to be revised, it kind of works but I cannot use the query builer.
   #+begin_src elisp
     (setq treesit-language-source-alist
	   '((bash . ("https://github.com/tree-sitter/tree-sitter-bash" "v0.21.0"))
	     (cmake . ("https://github.com/uyha/tree-sitter-cmake" "v0.5.0"))
	     (css . ("https://github.com/tree-sitter/tree-sitter-css" "v0.21.1"))
	     (elisp . ("https://github.com/Wilfred/tree-sitter-elisp" "1.6.0"))
	     (javascript . ("https://github.com/tree-sitter/tree-sitter-javascript" "v0.21.4" "src"))
	     (json . ("https://github.com/tree-sitter/tree-sitter-json" "v0.21.0"))
	     (tsx . ("https://github.com/tree-sitter/tree-sitter-typescript" "0.21.2" "tsx/src"))
	     (typescript . ("https://github.com/tree-sitter/tree-sitter-typescript" "0.21.2" "typescript/src"))
	     (vue . ("https://github.com/ikatyang/tree-sitter-vue" "v0.2.1"))))

     ;; (mapc #'treesit-install-language-grammar (mapcar #'car treesit-language-source-alist))

     (setq major-mode-remap-alist
	   '((bash-mode . bash-ts-mode)
	     (js2-mode . js-ts-mode)
	     (typescript-mode . typescript-ts-mode)
	     (json-mode . json-ts-mode)
	     (css-mode . css-ts-mode)	))

     ;; (setq treesit-language-source-alist
     ;;  '((vue "https://github.com/ikatyang/tree-sitter-vue")
     ;;    (css "https://github.com/tree-sitter/tree-sitter-css")
     ;;    (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")))

     ;; (mapc #'treesit-install-language-grammar '(vue css typescript))

     (use-package treesit-auto
       :custom
       (treesit-auto-install 'prompt)
       :custom
       (treesit-auto-add-to-auto-mode-alist 'all)
       ;;:init
       ;;(global-treesit-auto-mode)		;
       )



     ;; (setq treesit-auto-langs '(python typescript))

     ;; (setq treesit-auto-instal l 'prompt)
   #+end_src

** Tree Sitter Fold
   #+begin_src elisp
     (use-package ts-fold
       :config
       (global-ts-fold-mode))
   #+end_src
** Combobulate
   #+begin_src elisp
     (use-package combobulate
       :custom
       ;; You can customize Combobulate's key prefix here.
       ;; Note that you may have to restart Emacs for this to take effect!
       (combobulate-key-prefix "C-c o")

       ;; Optional, but recommended.
       ;;
       ;; You can manually enable Combobulate with `M-x
       ;; combobulate-mode'.
       :hook
       ((python-ts-mode . combobulate-mode)
	(js-ts-mode . combobulate-mode)
	(html-ts-mode . combobulate-mode)
	(css-ts-mode . combobulate-mode)
	(yaml-ts-mode . combobulate-mode)
	(typescript-ts-mode . combobulate-mode)
	(json-ts-mode . combobulate-mode)
	(tsx-ts-mode . combobulate-mode))
       ;; Amend this to the directory where you keep Combobulate's source
       ;; code.
       :load-path ("/home/cb0/.emacs.d/combobulate"))
   #+end_src
** Flycheck
   #+begin_src elisp
     (use-package flycheck
       :ensure t
       :init (global-flycheck-mode)
       :bind (:map flycheck-mode-map
		   ("M-n" . flycheck-next-error) ; optional but recommended error navigation
		   ("M-p" . flycheck-previous-error)))
   #+end_src
  
** LSP

*** Base installation
    #+begin_src elisp
      ;;add local path as it contains the lsp booster function
      (add-to-list 'exec-path "~/.local/bin")
      (add-to-list 'exec-path "/home/cb0/.cargo/bin")

      ;;(use-package json-ls)

      (use-package lsp-mode
	:diminish "LSP"
	:ensure t
	:hook ((lsp-mode . lsp-diagnostics-mode)
	       ;;	       (lsp-mode . lsp-enable-which-key-integration)
	       ((tsx-ts-mode
		 typescript-ts-mode
		 js-ts-mode-map		
		 ) . lsp-deferred))
	:custom
	(lsp-keymap-prefix "C-c l")           ; Prefix for LSP actions
	(lsp-completion-provider :none)       ; Using Corfu as the provider
	(lsp-diagnostics-provider :flycheck)
	(lsp-session-file (locate-user-emacs-file ".lsp-session"))
	(lsp-log-io nil)                      ; IMPORTANT! Use only for debugging! Drastically affects performance
	(lsp-keep-workspace-alive nil)        ; Close LSP server if all project buffers are closed
	(lsp-idle-delay 0.5)                  ; Debounce timer for `after-change-function'
	;; core
	(lsp-enable-xref t)                   ; Use xref to find references
	(lsp-auto-configure t)                ; Used to decide between current active servers
	(lsp-eldoc-enable-hover t)            ; Display signature information in the echo area
	(lsp-enable-dap-auto-configure t)     ; Debug support
	(lsp-enable-file-watchers nil)
	;;(lsp-enable-folding nil)              ; I disable folding since I use origami
	;;(lsp-enable-imenu t)
	;;(lsp-enable-indentation nil)          ; I use prettier
	(lsp-enable-links nil)                ; No need since we have `browse-url'
	;;(lsp-enable-on-type-formatting nil)   ; Prettier handles this
	(lsp-enable-suggest-server-download t) ; Useful prompt to download LSP providers
	(lsp-enable-symbol-highlighting t)     ; Shows usages of symbol at point in the current buffer
	(lsp-enable-text-document-color nil)   ; This is Treesitter's job

	(lsp-ui-sideline-show-hover nil)      ; Sideline used only for diagnostics
	(lsp-ui-sideline-diagnostic-max-lines 20) ; 20 lines since typescript errors can be quite big
	;; completion
	(lsp-completion-enable t)
	(lsp-completion-enable-additional-text-edit t) ; Ex: auto-insert an import for a completion candidate
	(lsp-enable-snippet t)                         ; Important to provide full JSX completion
	(lsp-completion-show-kind t)                   ; Optional
	;; headerline
	(lsp-headerline-breadcrumb-enable t)  ; Optional, I like the breadcrumbs
	(lsp-headerline-breadcrumb-enable-diagnostics nil) ; Don't make them red, too noisy
	(lsp-headerline-breadcrumb-enable-symbol-numbers nil)
	(lsp-headerline-breadcrumb-icons-enable nil)
	;; modeline
	(lsp-modeline-code-actions-enable nil) ; Modeline should be relatively clean
	(lsp-modeline-diagnostics-enable nil)  ; Already supported through `flycheck'
	(lsp-modeline-workspace-status-enable nil) ; Modeline displays "LSP" when lsp-mode is enabled
	(lsp-signature-doc-lines 1)                ; Don't raise the echo area. It's distracting
	(lsp-ui-doc-use-childframe t)              ; Show docs for symbol at point
	(lsp-eldoc-render-all nil)            ; This would be very useful if it would respect `lsp-signature-doc-lines', currently it's distracting
	;; lens
	(lsp-lens-enable nil)                 ; Optional, I don't need it
	;; semantic
	(lsp-semantic-tokens-enable nil)      ; Related to highlighting, and we defer to treesitter
	:config
	;; (lsp-enable-which-key-integration t)
	:bind (:map lsp-mode-map
		    ("C-c l t s" . lsp-treemacs-symbols)
		    ("C-c l d" . consult-lsp-diagnostics)
		    ("C-c l f s" . consult-lsp-file-symbols)
		    ("C-c l f q" . consult-lsp-file)
		    )
	:preface
	       ;; tune lsp mode performance
       (setq read-process-output-max (* 10 1024 1024)) ;; 10mb
       (setq gc-cons-threshold 200000000)

	(defun lsp-booster--advice-json-parse (old-fn &rest args)
	  "Try to parse bytecode instead of json."
	  (or
	   (when (equal (following-char) ?#)

	     (let ((bytecode (read (current-buffer))))
	       (when (byte-code-function-p bytecode)
		 (funcall bytecode))))
	   (apply old-fn args)))
	(defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
	  "Prepend emacs-lsp-booster command to lsp CMD."
	  (let ((orig-result (funcall old-fn cmd test?)))
	    (if (and (not test?)                             ;; for check lsp-server-present?
		     (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
		     lsp-use-plists
		     (not (functionp 'json-rpc-connection))  ;; native json-rpc
		     (executable-find "emacs-lsp-booster"))
		(progn
		  (message "Using emacs-lsp-booster for %s!" orig-result)
		  (cons "emacs-lsp-booster" orig-result))
	      orig-result)))
	:init
	(setq lsp-use-plists t)
	;; Initiate https://github.com/blahgeek/emacs-lsp-booster for performance
	(advice-add (if (progn (require 'json)
			       (fboundp 'json-parse-buffer))
			'json-parse-buffer
		      'json-read)
		    :around
		    #'lsp-booster--advice-json-parse)
	(advice-add 'lsp-resolve-final-command :around #'lsp-booster--advice-final-command))


    #+end_src

  
*** Plugins
**** LSP Treemacs
     CLOSED: [2024-08-16 Fr 16:15]
     :LOGBOOK:
     - CLOSING NOTE [2024-08-16 Fr 16:15]
     :END:
     #+begin_src elisp
       (use-package lsp-treemacs
	 :config
	 )

       (with-eval-after-load 'js
	 (define-key js-mode-map (kbd "M-.") nil))

       ;; (use-package lsp-completion		
       ;;   :no-require
       ;;   :hook ((lsp-mode . lsp-completion-mode)))

       (use-package lsp-ui
	 :ensure t
	 :commands
	 (lsp-ui-doc-show
	  lsp-ui-doc-glance)
	 :bind (:map lsp-mode-map
		     ("C-c d" . 'lsp-describe-thing-at-point)
		     ("C-c C-d" . 'lsp-ui-doc-glance))
	 :after (lsp-mode)
	 :config (setq lsp-ui-doc-enable t
		       evil-lookup-func #'lsp-ui-doc-glance ; Makes K in evil-mode toggle the doc for symbol at point
		       lsp-ui-doc-show-with-cursor nil      ; Don't show doc when cursor is over symbol - too distracting
		       lsp-ui-doc-include-signature t       ; Show signature
		       lsp-ui-doc-position 'at-point))

     #+end_src

** TODO Tailwind
   Cannot use as uses straight.
   #+begin_src elisp
     (use-package lsp-tailwindcss
       :init (slot/vc-install :fetcher "github" :repo "merrickluo/lsp-tailwindcss"))

     ;; (use-package lsp-tailwindcss
     ;;       :straight '(lsp-tailwindcss :type git :host github :repo "merrickluo/lsp-tailwindcss")
     ;;       :init (setq lsp-tailwindcss-add-on-mode t)
     ;;  :custom

     ;;       :config
     ;;       (dolist (tw-major-mode
     ;; 	       '(css-mode
     ;; 		 css-ts-mode
     ;; 		 typescript-mode
     ;; 		 typescript-ts-mode
     ;; 		 tsx-ts-mode
     ;; 		 js2-mode
     ;; 		 js-ts-mode
     ;; 		 clojure-mode))
     ;; 	(add-to-list 'lsp-tailwindcss-major-modes tw-major-mode)))
   #+end_src
** TODO eslint
   Cannot install atm because network issue ?? 
   #+begin_src elisp
     ;; (use-package lsp-eslint
     ;;       :demand t
     ;;       :after lsp-mode)

   #+end_src

** Navigation
   #+begin_src elisp
     (global-set-key (kbd "M-,") 'xref-go-back)
   #+end_src

** Project support  
*** Node
    #+begin_src elisp
      (use-package npm-mode)
      ;; (npm-global-mode)
    #+end_src
** Key Management
*** Duplicate Lines
    #+begin_src elisp
      (defun duplicate-line (arg)
	"Duplicate current line, leaving point in lower line."
	(interactive "*p")

	;; save the point for undo
	(setq buffer-undo-list (cons (point) buffer-undo-list))

	;; local variables for start and end of line
	(let ((bol (save-excursion (beginning-of-line) (point)))
	      eol)
	  (save-excursion

	    ;; don't use forward-line for this, because you would have
	    ;; to check whether you are at the end of the buffer
	    (end-of-line)
	    (setq eol (point))

	    ;; store the line and disable the recording of undo information
	    (let ((line (buffer-substring bol eol))
		  (buffer-undo-list t)
		  (count arg))
	      ;; insert the line arg times
	      (while (> count 0)
		(newline)         ;; because there is no newline in 'line'
		(insert line)
		(setq count (1- count)))
	      )

	    ;; create the undo information
	    (setq buffer-undo-list (cons (cons eol (point)) buffer-undo-list)))
	  ) ; end-of-let

	;; put the point in the lowest line and return
	(next-line arg))

      (global-set-key (kbd "C-c C-d") 'duplicate-line)
    #+end_src
   
** Projectile and Sidebar
   I want to have a IDE like tree explorer when I want it.
   #+begin_src elisp
     (use-package projectile
       :ensure t
       :config
       (projectile-mode +1)
       :bind (:map projectile-mode-map
	      ("C-c p" . projectile-command-map)))

   #+end_src
** Treemacs
   #+begin_src elisp

     ;; Install via package manager
     (use-package treemacs
       :ensure t
       :bind
       (:map global-map
	     ("M-1" . treemacs)          ;; Similar to ALT+1
	     ("C-c t" . treemacs))
       :config
       ;; Enable project integration
       (treemacs-project-follow-mode t)
       ;; Follow the currently selected file
       (treemacs-follow-mode t))

     ;; Add treemacs-projectile for better integration
     (use-package treemacs-projectile
       :ensure t)

   #+end_src
* Code Handling
** Region expanding
   #+begin_src elisp
     (use-package expand-region
       :config

     (global-set-key (kbd "C-]") 'er/expand-region))
     
   #+end_src
** Commenting of code
   When commenting code I use `M-,` to do this
*** Single line
    #+BEGIN_SRC emacs-lisp
      (defun comment-or-uncomment-region-or-line ()
	"Comments or uncomments the region or the current line if there's no active region."
	(interactive)
	(let (beg end)
	  (if (region-active-p)
	      (setq beg (region-beginning) end (region-end))
	    (setq beg (line-beginning-position) end (line-end-position)))
	  (comment-or-uncomment-region beg end)
	  (next-line)))

    #+END_SRC
*** Regions
    #+BEGIN_SRC emacs-lisp
      ;; (global-set-key (kbd "C-x C-;") 'comment-region)
      ;; (global-set-key (kbd "C-x C-:") 'uncomment-region)
    #+END_SRC

* File Handling
  
** Recentf
   To enable me to quickly navigate to my recent files, this mode is recommended.
   #+begin_src elisp
     (recentf-mode 1)
     (setq recentf-max-menu-items 25)
     (setq recentf-max-saved-items 25)
     (global-set-key  (kbd "C-x C-r") 'recentf-open-files)
   #+end_src
* Session Management
** Desktop mode
   #+BEGIN_SRC emacs-lisp
     (use-package desktop)
     (desktop-save-mode 1)
     (setq history-length 250)
     ;(add-to-list 'desktop-globals-to-save 'file-name-history)

     (defun my-desktop-save ()
       (interactive)
       ;; Don't call desktop-save-in-desktop-dir, as it prints a message.
       (if (eq (desktop-owner) (emacs-pid))
	   (desktop-save desktop-dirname)))
     (add-hook 'auto-save-hook 'my-desktop-save)

     ;;(desktop-read)

  #+END_SRC
* Autocomplete
  #+BEGIN_SRC emacs-lisp
    ;;(use-package company)
    ;;(add-hook 'after-init-hook 'global-company-mode)
  #+END_SRC
* Key Management
** Set default font size
   #+begin_src elisp

     (text-scale-set 4)
   #+end_src
** [#B] Font size handling
   In/Decrease the font size with `C-+` and `C--`
   #+BEGIN_SRC emacs-lisp
     (define-key global-map (kbd "C-+") 'text-scale-increase)
     (define-key global-map (kbd "C--") 'text-scale-decrease)
     (define-key global-map (kbd "C-=") 'text-scale-decrease)
   #+END_SRC
** Window Handling
*** Resize Windows
    In split mode I use `S-C` with arrow keys for resizing windows.
    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "S-C-<left>") 'shrink-window-horizontally)
      (global-set-key (kbd "S-C-<right>") 'enlarge-window-horizontally)
      (global-set-key (kbd "S-C-<up>") 'shrink-window)
      (global-set-key (kbd "S-C-<down>") 'enlarge-window)
    #+END_SRC
*** Jump between windows
    #+BEGIN_SRC emacs-lisp
      ;; Jump backwards between windows
      (defun other-window-backward (n)
	"Select Nth previous window."
	(interactive "p")
	(other-window (- n)))

      ;;bind switching between windows to SHIFT-UP/DOWN (super usefull!!!!)
      ;;does not work in org files, therefore use win-[UP/DOWN]
      (global-set-key [(shift down)] 'other-window)
      (global-set-key [(shift up)] 'other-window-backward)
    #+END_SRC

*** Zoom windows
    #+BEGIN_SRC emacs-lisp
      (use-package zoom-window)
      ;; ;;(setq zoom-window-use-elscreen t)
      (zoom-window-setup)

      (global-set-key (kbd "C-x C-z") 'zoom-window-zoom)
    #+END_SRC

* Tramp
** Clean up tramp connections
   When opening directories over tramp and not closing them manually, the minibuffer sometimes ask for a ssh pass while doing something completly different.
   This is because the directories are still open inside `ido-dir-file-cache`. Searching [[https://www.emacswiki.org/emacs/TrampMode#toc13][emacs wiki]] I found this snipper which will remove these connections from `ido-dir-file-cache`
   This conatains of a function for removing those buffers.
   #+BEGIN_SRC emacs-lisp
     (defun ido-remove-tramp-from-cache nil
       "Remove any TRAMP entries from `ido-dir-file-cache'.
         This stops tramp from trying to connect to remote hosts on emacs startup,
         which can be very annoying."
       (interactive)
       (setq ido-dir-file-cache
             (cl-remove-if
              (lambda (x)
                (string-match "/\\(rsh\\|ssh\\|telnet\\|su\\|sudo\\|sshx\\|krlogin\\|ksu\\|rcp\\|scp\\|rsync\\|scpx\\|fcp\\|nc\\|ftp\\|smb\\|adb\\):" (car x)))
              ido-dir-file-cache)))
     ;; redefine 'ido-kill-emacs-hook' so that cache is cleaned before being saved
     (defun ido-kill-emacs-hook ()
       (ido-remove-tramp-from-cache)
       (ido-save-history))
   #+END_SRC
   
* Chrome Link Store
  #+begin_src elisp
	(use-package web-server)

	(require 'web-server)

    ;; (ws-start
    ;;  (lambda (request)
    ;;    (with-slots (headers process) request
    ;;      (let (status msg)
    ;;        (if-let ((title (assoc-default "title" headers))
    ;;                 (url   (assoc-default "url"   headers)))
    ;;            (progn
    ;;              (setq title (decode-coding-string title 'utf-8))
    ;;              (kill-new (org-link-make-string url title))
    ;;              (message "Copied: %s" (car kill-ring))
    ;;              (setq status 200 msg "OK"))
    ;;          (setq status 400 msg "Failed"))
    ;;        (ws-response-header
    ;;         process status
    ;;         '("Content-type" . "text/plain")
    ;;         `("Content-Length" . ,(string-bytes msg)))
    ;;        (process-send-string process msg))))
    ;;  4444)
  #+end_src

* TODO EMMS
  Music, we need more music!
  #+begin_src elisp
    (use-package emms
      :config
      (emms-all)
      (emms-default-players)
      (setq-default
       emms-source-file-default-directory "~/Music/"

       emms-source-playlist-default-format 'm3u
       emms-playlist-mode-center-when-go t
       emms-playlist-default-major-mode 'emms-playlist-mode
       emms-show-format "NP: %s"

       emms-player-list '(emms-player-mpv)
       emms-player-mpv-environment '("PULSE_PROP_media.role=music")
       emms-player-mpv-parameters '("--quiet" "--really-quiet" "--no-video" "--no-audio-display" "--force-window=no" "--vo=null")))

  #+end_src
* All the icons
  #+begin_src elisp
	(use-package all-the-icons
	  :if (display-graphic-p))
    ;;    (all-the-icons-install-fonts)

    (use-package all-the-icons-completion
      :init
	(all-the-icons-completion-mode)
	(add-hook 'marginalia-mode-hook #'all-the-icons-completion-marginalia-setup))

    (use-package all-the-icons-dired)
  #+end_src

* Counsel
  #+BEGIN_SRC emacs-lisp
    ;;(use-package counsel)

     (use-package counsel
       :custom (counsel-linux-app-format-function #'counsel-linux-app-format-function-name-pretty))
    ;;(global-set-key (kbd "C-x C-f") counsel-find-file)

  #+END_SRC

* Vertico
  I used to use ivy, but have seen [[https://youtu.be/d3aaxOqwHhI?si=-qnBNB9gz3gwo40K][vertico]] presentation here and liked it and want to try it aswell.

  #+begin_src elisp
    (use-package vertico
      :bind (:map vertico-map
		  ("C-j" . vertico-next)
		  ("C-k" . vertico-previous)
		  ("C-f" . vertico-exit)
		  ("<tab>" . vertico-insert)
		  ("<escape>" . minibuffer-keyboard-quit)
		  ("C-M-n" . vertico-next-group)
		  ("C-M-p" . vertico-previous-group)
		  :map minibuffer-local-map
		  ("M-h" . backward-kill-word))
      :custom
      (vertico-cycle t)
      (vertico-resize nil)
      :init
      (vertico-mode))

    ;; Persist history over Emacs restarts. Vertico sorts by history position.
    (use-package savehist
      :ensure t
      :init
      (savehist-mode))

    ;; A few more useful configurations...
    (use-package emacs
      :custom
      ;; Support opening new minibuffers from inside existing minibuffers.
      (enable-recursive-minibuffers t)
      ;; Emacs 28 and newer: Hide commands in M-x which do not work in the current
      ;; mode.  Vertico commands are hidden in normal buffers. This setting is
      ;; useful beyond Vertico.
      (read-extended-command-predicate #'command-completion-default-include-p)
      :init
      ;; Add prompt indicator to `completing-read-multiple'.
      ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
      (defun crm-indicator (args)
	(cons (format "[CRM%s] %s"
		      (replace-regexp-in-string
		       "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
		       crm-separator)
		      (car args))
	      (cdr args)))
      (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

      ;; Do not allow the cursor in the minibuffer prompt
      (setq minibuffer-prompt-properties
	    '(read-only t cursor-intangible t face minibuffer-prompt))
      (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode))

    (use-package marginalia
      :after vertico
      :ensure t
      :custom
      (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
      :init
      (marginalia-mode))

    ;; (use-package marginalia
    ;;   :ensure t
    ;;   :config
    ;;   (marginalia-mode))

    ;; from https://youtu.be/d3aaxOqwHhI?si=-qnBNB9gz3gwo40K
    ;; The `orderless' package lets the minibuffer use an out-of-order
    ;; pattern matching algorithm.  It matches space-separated words or
    ;; regular expressions in any order.  In its simplest form, something
    ;; like "ins pac" matches `package-menu-mark-install' as well as
    ;; `package-install'.  This is a powerful tool because we no longer
    ;; need to remember exactly how something is named.
    ;;
    ;; Note that Emacs has lots of "completion styles" (pattern matching
    ;; algorithms), but let us keep things simple.
    ;;
    ;; Further reading: https://protesilaos.com/emacs/dotemacs#h:7cc77fd0-8f98-4fc0-80be-48a758fcb6e2

    (use-package embark
      :ensure t

      :bind
      (("C-." . embark-act)         ;; pick some comfortable binding
       ("C-;" . embark-dwim)        ;; good alternative: M-.
       ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

      :init

      ;; Optionally replace the key help with a completing-read interface
      (setq prefix-help-command #'embark-prefix-help-command)

      ;; Show the Embark target at point via Eldoc. You may adjust the
      ;; Eldoc strategy, if you want to see the documentation from
      ;; multiple providers. Beware that using this can be a little
      ;; jarring since the message shown in the minibuffer can be more
      ;; than one line, causing the modeline to move up and down:

      ;; (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
      ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

      :config

      ;; Hide the mode line of the Embark live/completions buffers
      (add-to-list 'display-buffer-alist
		   '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
		     nil
		     (window-parameters (mode-line-format . none)))))

  #+end_src

  #+RESULTS:
  : embark-bindings
  
* consult
  #+begin_src elisp

    (setq read-file-name-completion-ignore-case t)

    (setq consult-async-min-input 1)

    (use-package consult
      :config
      (setq consult-async-min-input 1)

      ;; Show candidates immediately when typing
      (setq consult-async-min-input 1)

      ;; Optional: make async search more responsive
      (setq consult-async-input-throttle 0.2)
      (setq consult-async-input-debounce 0.1)
      (global-set-key (kbd "C-x b") 'consult-buffer)
      (global-set-key (kbd "C-x g") 'consult-git-grep)
      (global-set-key (kbd "C-x C-k a") 'consult-ag)
      (global-set-key (kbd "C-x C-k f") 'consult-locate)
      (global-set-key (kbd "C-s") 'consult-line))

    (setq completion-ignore-case t)
    (setq read-file-name-completion-ignore-case t)
    (setq read-buffer-completion-ignore-case t)

    (use-package consult-lsp)

    (define-key lsp-mode-map [remap xref-find-apropos] #'consult-lsp-symbols)

    ;; Consult users will also want the embark-consult package.
    (use-package embark-consult
      :ensure t ; only need to install it, embark loads it after consult if found
      :hook
      (embark-collect-mode . consult-preview-at-point-mode))

    (use-package embark-org-roam)
  #+end_src
* Http Helper
** Ob-http
   To be able to use emacs org-mode's bable feature and make request and get responses, I need this package first.
   #+begin_src elisp
     (use-package ob-http)
   #+end_src

   Later I will tell org-mode to use it. See [[*Install and set custom things for org-mode][Install and set custom things for org-mode]].
* Avy - former AceJump
  #+begin_src elisp
    (use-package avy
      :config
      (global-set-key (kbd "C-c j") 'avy-goto-word-or-subword-1)
      (global-set-key (kbd "s-.") 'avy-goto-word-or-subword-1))
  #+end_src
* Org Mode
** Install and set custom things for org-mode
   :LOGBOOK:
   CLOCK: [2024-07-25 Do 22:33]--[2024-07-26 Fr 00:33] =>  2:00
   :END:
   #+BEGIN_SRC emacs-lisp
						  ; Activate org-mode
	  (use-package org)

     ;; (require 'org-install)
	  ;; (use-package org-habit)
	  ;; (setq org-habit-preceding-days 7
	  ;; org-habit-following-days 1
	  ;; org-habit-graph-column 80
	  ;; org-habit-show-habits-only-for-today t
	  ;; org-habit-show-all-today t)
	  ;;(require 'ess-site)
	  ;; http://orgmode.org/guide/Activation.html#Activation

	  ;; The following lines are always needed.  Choose your own keys.
	  (add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))

	  ;; And add babel inline code execution
	  ;; babel, for executing code in org-mode.
	  (org-babel-do-load-languages
	   'org-babel-load-languages
	   ;; load all language marked with (lang . t).
	   '((C . t)
	     ( http . t)
	     ;;	(org . t)
	     (shell . t)))

	  ;; turn off "evaluate code question" in org-mode code blocks
	  (setq org-confirm-babel-evaluate nil)

	  ;; and some more org stuff
	  (setq org-list-allow-alphabetical t)

	  (define-key global-map "\C-cl" 'org-store-link)
	  (define-key global-map "\C-ca" 'org-agenda)
	  ;; add a timestamp when we close an item
	  (setq org-log-done 'note)
     (setq org-treat-insert-todo-heading-as-state-change t)
     (setq org-log-into-drawer t)
	  ;; include a closing note when close an todo item
	  ;; (setq org-log-done 'note)

	  ;;(global-set-key "\C-cl" 'org-store-link)
	  ;; (global-set-key "\C-cc" 'org-capture)
	  ;; (global-set-key "\C-ca" 'org-agenda)
	  ;; (global-set-key "\C-cb" 'org-iswitchb)
	  ;; (global-set-key (kbd "<S-i>") 'org-clock-in)
	  ;; (global-set-key (kbd "<S-o>") 'org-clock-out)
	  ;; (global-set-key (kbd "<S-g>") 'org-clock-goto)



	  (custom-set-variables
	   '(org-agenda-files (directory-files-recursively "~/sync/org/" "\\.org$")))
	   '(org-agenda-ndays 7)
	   '(org-deadline-warning-days 14)
	   '(org-agenda-show-all-dates t)
	   '(org-agenda-skip-deadline-if-done t)
	   '(org-agenda-skip-scheduled-if-done t)
	   '(org-agenda-start-on-weekday nil)
	   '(org-reverse-note-order t)
	   '(org-fast-tag-selection-single-key (quote expert))


	  (global-set-key "\C-cr" 'org-capture)

	  ;; Org Capture
	  ;; (setq org-capture-templates
	  ;; '(("t" "Todo" entry (file+headline (concat org-directory "/gtd.org") "Tasks")
	  ;; "* TODO %?\n %i\n")
	  ;; ("l" "Link" plain (file (concat org-directory "/links.org"))
	  ;; "- %?\n %x\n")))


	   ;; '(org-remember-templates
	     ;; (quote ((116 "* TODO %?\n  %u" "~/todo.org" "Tasks")
		  ;; (110 "* %u %?" "~/notes.org" "Notes"))))
	   ;; '(remember-annotation-functions (quote (org-remember-annotation)))
	  ;;  '(remember-handler-functions (quote (org-remember-handler))))

	  ;; (package-require 'org-ac)
	  ;; (package-require 'org-tempo)

	  ;; To save the clock history across Emacs sessions:
	  (setq org-clock-persist 'history)
	  (org-clock-persistence-insinuate)
	  (setq org-clock-continuously nil)

	  ;; we want some non standard todo types
	  (setq org-todo-keywords
		'((sequence
		   "TODO(t)" "NEED_FEEDBACK(f)" "|" "CANCELED(c)" "DONE(d)")))

	  (setq org-todo-keyword-faces
		'(("TODO" :background "red1" :foreground "black" :weight bold :box (:line-width 2 :style released-button))
		  ("NEED_FEEDBACK" :background "yellow" :foreground "black" :weight bold :box (:line-width 2 :style released-button))
		  ("DONE" :background "forest green" :weight bold :box (:line-width 2 :style released-button))
		  ("CANCELLED" :background "lime green" :foreground "black" :weight bold :box (:line-width 2 :style released-button))))

	  ;; dont ask when executing code
	  (setq org-confirm-babel-evaluate nil)

	  (defface org-block-begin-line
	    '((t (:underline "#A7A6AA" :foreground "#040404" :background "#9a9a9a")))
	    "Face used for the line delimiting the begin of source blocks.")

	  (defface org-block-background
	    '((t (:background "#4F4F4F")))
	    "Face used for the source block background.")

	  (defface org-block-end-line
	    '((t (:overline "#A7A6AA" :foreground "#000000" :background "#9a9a9a")))
	    "Face used for the line delimiting the end of source blocks.")

	  (setq org-completion-use-ido t)

	  (setq exec-path (append exec-path '("/usr/bin/mscgen")))

	  (defun do-org-show-all-inline-images ()
	    (interactive)
	    (org-display-inline-images t t))

	  ;; (add-hook 'org-ctrl-c-ctrl-c-hook (lambda () (org-display-inline-images)))
	  ;;(add-hook 'org-confirm-babel-evaluate-hook (lambda () (org-display-inline-images)))

	  (add-hook 'org-babel-after-execute-hook
		    (lambda ()
		      (condition-case nil
			  (org-display-inline-images)
			(error nil)))
		    'append)

	  ;; set so that each line has correct indent
	  (setq org-adapt-indentation t)

   #+END_SRC
*** Fixing the insertion of source blocks in emacs org > 9.2

    As written [[https://github.com/syl20bnr/spacemacs/issues/11798#issuecomment-454941024][here]] the short syntax '>s' + 'TAB' does not expand into a bable source code block.
    The next code block will fix this.

    #+begin_src emacs-lisp
	(when (version<= "9.2" (org-version))
	  (require 'org-tempo))
    #+end_src

** Super Agenda
   #+begin_src elisp
     ;; (use-package org-super-agenda)
     ;; (org-super-agenda-mode)
     ;; (let ((org-super-agenda-groups
     ;;        '(;; Each group has an implicit boolean OR operator between its selectors.
     ;; 	 (:name "Today"  ; Optionally specify section name
     ;; 		:time-grid t  ; Items that appear on the time grid
     ;; 		:todo "TODAY")  ; Items that have this TODO keyword
     ;; 	 (:name "Important"
     ;; 		;; Single arguments given alone
     ;; 		:tag "work"
     ;; 		:priority "A"))))
     ;;   (org-agenda nil "a"))
   #+end_src
*** Integrate radicale online calendar
    #+begin_src elisp
     (use-package org-caldav)
     (setq org-caldav-url "https://cal.0xcb0.com/")
     (setq org-caldav-calendar-id "cb0/53ba00fd-502f-8b48-c01d-bd339a3ef42a")
     (setq org-caldav-inbox "~/org/calendar.org")
     (setq org-caldav-files ())
     (setq org-icalendar-timezone "Europe/Berlin")

     (global-set-key (kbd "C-c y") 'org-caldav-sync)

   #+end_src
*** Configure calendar usage
    #+begin_src elisp
      (setq calendar-week-start-day 1)
      (setq diary-number-of-entries 14)
      (appt-activate t)

      (global-set-key (kbd "C-c c") 'calendar)
      ;; use the same diary file as the one from caldav
      (setq diary-file org-caldav-inbox)
    #+end_src
*** Show week number in calendar
    #+begin_src elisp
      (copy-face font-lock-constant-face 'calendar-iso-week-face)
      (set-face-attribute 'calendar-iso-week-face nil
			  :height 0.7)
      (setq calendar-intermonth-text
	    '(propertize
	      (format "%2d"
		      (car
		       (calendar-iso-from-absolute
			(calendar-absolute-from-gregorian (list month day year)))))
	      'font-lock-face 'calendar-iso-week-face))
    #+end_src
** WC
   [[https://github.com/bnbeckwith/wc-mode][org-wd]] is a minor mode for counting words.
   #+BEGIN_SRC emacs-lisp
     (use-package org-wc)

     ;; and run org-wc-display on a timer every time I go idle for 5 seconds
     (defun pc/display-org-wc-in-buffer ()
       "Calls org-wc-display in the buffer if timer is set."
       (when (timerp pc/org-wc-display-timer)
         (call-interactively 'org-wc-display)))

     (defun pc/setup-org-wc-display-timer ()
       "Function to setup a buffer local timer."
       (interactive)

       (defvar pc/org-wc-display-timer nil
         "Buffer-local timer.")

       (let ((buffer (current-buffer)))
         (setq pc/org-wc-display-timer
               (run-with-idle-timer 2 t 'pc/display-org-wc-in-buffer))))

     (defun pc/cancel-org-wc-display-timer ()
       "Cancel the timer once we are done."
       (interactive)
       (when (timerp pc/org-wc-display-timer)
         (cancel-timer pc/org-wc-display-timer)))

   #+END_SRC
** Customizations
*** Quick open homenotes
    As I use the file `homenotes.org` the most often, I set up a key binding to open it up very quickly.
    #+BEGIN_SRC emacs-lisp
      ;; (global-set-key (kbd "C-c o")
      ;;                 (lambda () (interactive) (find-file "~/sync/org/old/homenotes.org")))
    #+END_SRC
*** Increase refile level
    By default org-refile only shows top level entries. With inspiration taken from [[http://sachachua.com/blog/2015/02/learn-take-notes-efficiently-org-mode/][sachachua]] I will increase this level to 5.
    #+BEGIN_SRC emacs-lisp
      (setq org-refile-targets '((org-agenda-files . (:maxlevel . 5))))
    #+END_SRC
** Agenda
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-c a") 'org-agenda)
     (global-set-key (kbd "C-c c") 'org-capture)
   #+END_SRC

** Babel
*** Structure Templates

    As described [[info:org#Structure Templates][here]] I do want to extend my templates to be able to quickly write various code blocks like

    #+begin_export ascii
      #+BEGIN_SRC emacs-lisp
      #+END_SRC
    #+end_export

    #+begin_src elisp
      (setq org-structure-template-alist '(("a" . "export ascii")
					  ("C" . "comment")
					  ("b" . "src bash")
					  ("e" . "src elisp")
					  ("E" . "export")
					  ("h" . "export html")
					  ("j" . "json")
					  ("l" . "export latex")
					  ("q" . "quote")
					  ("s" . "src")
					  ("v" . "verse")))
    #+end_src

    #+begin_src bash
      echo "Test"
    #+end_src

    #+RESULTS:
    : Test
    
*** Remote dir fix!
    When evaluation source blocks inside org mode I get the same error as [[https://lists.gnu.org/archive/html/emacs-orgmode/2016-01/msg00281.html][here]].
    There is a fix for this by [[http://www.howardism.org/Technical/Emacs/literate-devops.html#fn.2][Howard]] but it involves adjusting org-mode source code. As this might change when updating, I will use this solution, proposed by John Kitchin [[https://lists.gnu.org/archive/html/emacs-orgmode/2016-01/msg00321.html][here]].
    #+BEGIN_SRC emacs-lisp
      (setq temporary-file-directory "/tmp/")
    #+END_SRC
** Corg
   Looks like a great additional package I just [[https://isamert.net/2024/08/20/corg-el-announcement.html][found today]] (<2024-08-30 Fr>). And it was only released a week ago.

   #+begin_src elisp
     (use-package corg
       :init
       (slot/vc-install :fetcher "github" :repo "isamert/corg.el")
       (add-hook 'org-mode-hook #'corg-setup))
   #+end_src
** Custom functions
*** Aggregate all nodes without headings into a new buffer
    For my wedding speech I added a lot of notes, infos and stuff info a org mode buffer.
    Now I want to quickly get all the text in that node and all subnotes. But without the headings.
    This is what this function should do.
    #+begin_src elisp
      (defun cb0/org-collect-content-without-headings ()
	(interactive)
	(let ((content ""))
	  (org-map-entries
	   (lambda ()
	     (setq content
		   (concat content
			   (buffer-substring-no-properties
			    (line-beginning-position 2)
			    (org-entry-end-position))
			   "\n\n"))))
	  (with-current-buffer (get-buffer-create "*Org Content Without Headings*")
	    (erase-buffer)
	    (insert content)
	    (goto-char (point-min))
	    (while (re-search-forward "^\\*+ .*\n" nil t)
	      (replace-match ""))
	    (switch-to-buffer (current-buffer)))))

      (defun cb0/org-collect-content-without-headings-current-subtree ()
	(interactive)
	(save-excursion
	  (org-back-to-heading t)
	  (let ((start (point))
		(end (save-excursion (org-end-of-subtree t t)))
		(content ""))
	    (org-map-entries
	     (lambda ()
	       (setq content
		     (concat content
			     (buffer-substring-no-properties
			      (line-beginning-position 2)
			      (org-entry-end-position))
			     "\n\n")))
	     t 'tree)
	    (with-current-buffer (get-buffer-create "*Org Content Without Headings*")
	      (erase-buffer)
	      (insert content)
	      (goto-char (point-min))
	      (while (re-search-forward "^\\*+ .*\n" nil t)
		(replace-match ""))
	      (switch-to-buffer (current-buffer))))))
    #+end_src
* Org Roam
** Installation
   #+begin_src elisp
     (use-package org-roam
       :ensure t
       :init
       (setq org-roam-v2-ack t)
       :custom
       (org-roam-directory "~/sync/org/org-roam")
       (org-roam-dailies-directory "journal/")
       (org-roam-completion-everywhere t)
       (org-roam-capture-templates
	'(("d" "default" plain
	   "%?"
	   :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
	   :unnarrowed t)
	  ("p" "project" plain "%?"
	   :if-new
	   (file+head "project-ideas/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: :projectIdea:\n#+created: <%<%Y-%m-%d %a %H:%M>>\n")
	   :immediate-finish t
	   :unnarrowed t)))

       (org-roam-dailies-capture-templates
	     '(("d" "default" entry "* %<%I:%M %p>: %?"
		:if-new (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n"))
	       ("j" "journal" entry
		"** <%<%Y-%m-%d %a %H:%M>>: %?"
		:if-new (file+head "%<%Y-%m-%d>.org"
				   "#+title: %<%Y-%m-%d>\n\n* <%Y-%m-%d %a %H:%M>\n")
		:unnarrowed t)
	       ("w" "work" entry
		"** %<%H:%M>"
		:if-new (file+head "work-%<%Y-%m-%d>.org"
				   "#+title: %<%Y-%m-%d>\n\n* Work journal\n")
		:unnarrowed t)
	       ))


       :bind (("C-c n l"   . org-roam-buffer-toggle)
	      ("C-c n f"   . org-roam-node-find)
	      ("C-c n i"   . org-roam-node-insert)
	      ("C-c n _"   . org-id-get-create)
	      ("C-c n a"   . org-roam-alias-add)
	      ("C-c n d"   . org-roam-dailies-goto-date)
	      ("C-c n c"   . org-roam-dailies-capture-today)
	      ("C-c n C r" . org-roam-dailies-capture-tomorrow)
	      ("C-c n I"   . org-roam-node-insert-immediate)
	      ("C-c n t"   . org-roam-dailies-goto-today)
	      ("C-c n y"   . org-roam-dailies-goto-yesterday)
	      ("C-c n r"   . org-roam-dailies-goto-tomorrow)
	      ("C-c n R"   . my/org-roam-refresh-agenda-list)	     
	      ("C-c n g"   . org-roam-graph)
	      :map org-mode-map
	      ("C-M-i"     . completion-at-point))
       :config

       (defun org-roam-node-insert-immediate (arg &rest args)
	 "Insert a ref to a new roam note at buffer position, without jumping to that buffer."
	 (interactive "P")
	 (let ((args (cons arg args))
	       (org-roam-capture-templates (list (append (car org-roam-capture-templates)
							 '(:immediate-finish t)))))
	   (apply #'org-roam-node-insert args)))

       (defun my/org-roam-filter-by-tag (tag-name)
	 "Check if a tag is part of a node tags"
	 (lambda (node)
	   (member tag-name (org-roam-node-tags node))))

       (defun my/org-roam-list-notes-by-tag (tag-name)
	 "Filter my roam node files by a tag name"
	 (mapcar #'org-roam-node-file
		 (seq-filter
		  (my/org-roam-filter-by-tag tag-name)
		  (org-roam-node-list))))

       (defun my/org-roam-refresh-agenda-list ()
	 "Refresh the org-agenda-files with all my tags that I want to include."
	 (interactive)
	 (setq org-agenda-files (directory-files-recursively "~/sync/org/" "\\.org$")))
       ;; (setq org-agenda-files (my/org-roam-list-notes-by-tag "work")))

       (org-roam-setup)
       (org-roam-db-autosync-mode))

   #+end_src

   #+RESULTS:
   : completion-at-point

* Org Habits
  #+begin_src elisp
    (add-to-list 'org-modules 'org-habit t)
    (setq org-habit-show-all-today t)
  #+end_src

* Anki
  #+begin_src elisp
    (use-package anki-editor
      :after org
      :config
      ; I like making decks
      (setq anki-editor-create-decks 't))
  #+end_src

* Magit
  The best git client available
** init magit
   #+BEGIN_SRC emacs-lisp
     ;; git and magit (Magit rules!!!!)
     ;; (require 'git)
     (use-package magit)
     (global-set-key (kbd "<f5>") 'magit-status)
     (global-set-key (kbd "C-x RET m") 'magit-status)

     ;;taken from http://tullo.ch/articles/modern-emacs-setup/
     ;; (defadvice magit-status (around magit-fullscreen activate)
     ;;   "Make magit-status run alone in a frame."
     ;;   (window-configuration-to-register :magit-fullscreen)
     ;;   ad-do-it
     ;;   (delete-other-windows))

     (defun magit-quit-session ()
       "Restore the previous window configuration and kill the magit buffer."
       (interactive)
       (kill-buffer)
       (jump-to-register :magit-fullscreen))

     (define-key magit-status-mode-map (kbd "q") 'magit-quit-session)

     ;;magit update recommendation
     ;;Note from update: Before running Git, Magit by default reverts all unmodified buffers which visit files tracked in the current repository. This can potentially lead to dataloss so you might want to disable this by adding the following line to your init file:
     (setq magit-auto-revert-mode nil)

     ;;prevent magit update message 1.4
     ;;(setq magit-last-seen-setup-instructions "1.4.0")

     (setq magit-completing-read-function 'magit-ido-completing-read)
     ;; (package-require 'ido-ubiquitous)
     ;; (ido-ubiquitous-mode 1)
   #+END_SRC
** Magit Customization
   #+BEGIN_SRC elisp
     (defun magit-stash-clear (ref)
       "Remove all stashes saved in REF's reflog by deleting REF."
       (interactive (let ((ref (or (magit-section-value-if 'stashes) "refs/stash")))
		      (magit-confirm t (format "Drop all stashes in %s" ref))
		      (list ref)))
     (message "To prevent from dropping all stashes again, this was disabled!"))
   #+END_SRC

* secretaria
  #+BEGIN_SRC emacs-lisp
    ;; (use-package secretaria
		 ;; :config
		 ;; use this for getting a reminder every 30 minutes of those tasks scheduled
		 ;; for today and which have no time of day defined.
		 ;; (add-hook 'after-init-hook #'secretaria-today-unknown-time-appt-always-remind-me))
  #+END_SRC

* XML Processing
** reformat/pretty print xml
   As always in emacs, there are [[http://stackoverflow.com/questions/12492/pretty-printing-xml-files-on-emacs][multiple options]] for the task of reformating a xml.
*** build in sgml mode
    Here I use sgml mode with pretty print and my known key combination "Control+Shift+L" to reformat code.
    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-S-l") 'sgml-pretty-print)
    #+END_SRC
*** using external xmllint
    We could also use `xmllint` which "might" be more applicable for large xml (to be tested).
    #+BEGIN_SRC emacs-lisp
      (defun xmllint-region (&optional b e)
        (interactive "r")
        (shell-command-on-region b e "xmllint --format -" t))
      ;;(global-set-key (kbd "C-M-l") 'xmlling-region)
    #+END_SRC
* Multiple Coursors
** Key Configuration:
   #+BEGIN_SRC emacs-lisp
     (use-package multiple-cursors)
     (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
     (global-set-key (kbd "C->") 'mc/mark-next-like-this)
     (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
     (global-set-key (kbd "C-c C-<down>") 'mc/mark-all-like-this)


   #+END_SRC
* LLMs
** Shell Maker
   #+begin_src elisp
     (use-package shell-maker)
     
   #+end_src
** ChatGPT
   See [[https://github.com/xenodium/chatgpt-shell/issues/217][here]] for super usefull tipps!
   #+begin_src elisp
     (setenv "ANTHROPIC_API_KEY" cb0/claude-shell-api-token)

       (use-package chatgpt-shell
	:ensure t
	:custom
	(chatgpt-shell-api-url-base "http://127.0.0.1:4000")
	(chatgpt-shell-openai-key cb0/chatgpt-shell-openai-key))

     (setq chatgpt-shell-openai-key
      (auth-source-pick-first-password :host "api.deepseek.com"))

      (require 'ob-chatgpt-shell)
      (ob-chatgpt-shell-setup)
   #+end_src
** Claude AI
   #+begin_src elisp
     (use-package claude-shell
       :custom
       (claude-shell-api-token cb0/claude-shell-api-token)
       (claude-shell-streaming t))
   #+end_src
** NEED_FEEDBACK ahyatt/llm
   This package looks promising, but it is not completed and I do not see how to build it hassle free.
   https://lists.gnu.org/archive/html/emacs-devel/2024-01/msg01134.html
   #+begin_src elisp

	       (defun my-llm-get-key (host)
	     (plist-get (car (auth-source-search :host host)) :secret))
	     (my-llm-get-key "api.openai.com")

     ;;     ;; (use-package llm-refactoring
     ;;     ;;   :init
     ;;     ;;   (require 'llm-openai)
     ;;     ;; (setq llm-refactoring-provider (make-llm-openai :key (my-llm-get-key "api.openai.com"))))

     ;; (use-package llm)
     ;; (use-package llm-flows)

     ;;     (use-package llm)
   #+end_src
   #+begin_src elisp

   #+end_src
** gptel
   #+begin_src elisp
     (use-package gptel
       :config
       ;; :key can be a function that returns the API key.
       (gptel-make-gemini "Gemini My" :key (my-llm-get-key "api.openai.com") :stream t)
       ;; DeepSeek offers an OpenAI compatible API
       (gptel-make-openai "DeepSeek mein"
	 :host "api.deepseek.com"
	 :endpoint "/chat/completions"
	 :stream t
	 :key (my-llm-get-key "api.deepseek.com")
	 :models '(deepseek-chat deepseek-reasoner)))
   #+end_src
*** Babel integration
    #+begin_src elisp
;;      (org-babel-do-load-languages
;;  'org-babel-load-languages
;; '((llm . t)))

(defun org-babel-execute:llm (body params)
  (gptel-request body :stream nil))
    #+end_src
* Productivity tweaks
** Pomodore timing
   #+begin_src elisp
     (use-package pomm
       :custom
       (pomm-audio-enabled t))
   #+end_src
ChatGPT(4/General)> Please tell me a joke
<shell-maker-end-of-prompt>


ChatGPT(4o/General)> 
